theory ex1 begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman
functions: fst/1, g/0, mac/2, pair/2, shk/0[private,destructor], snd/1
equations: fst(<x.1, x.2>) = x.1, snd(<x.1, x.2>) = x.2







rule (modulo E) Step1:
   [ Fr( ~tid ), Fr( ~x ) ]
  -->
   [ Out( <g^~x, mac(shk, <g^~x, $A, $B>)> ), Step1( ~tid, $A, $B, ~x ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Step2:
   [ Step1( tid, A, B, ~x ), In( <Y, mac(shk, <Y, B, A>)> ) ]
  --[ Accept( tid, Y^~x ) ]->
   [ ]

  /*
  rule (modulo AC) Step2:
     [ Step1( tid, A, B, ~x ), In( <Y, mac(shk, <Y, B, A>)> ) ]
    --[ Accept( tid, z ) ]->
     [ ]
    variants (modulo AC)
    1. ~x    = ~x.2
       Y     = x.5^inv(~x.2)
       z     = x.5
    
    2. Y     = DH_neutral
       z     = DH_neutral
    
    3. ~x    = ~x.2
       Y     = Y.2
       z     = Y.2^~x.2
    
    4. ~x    = ~x.4
       Y     = x.2^x.3
       z     = x.2^(x.3*~x.4)
    
    5. ~x    = ~x.2
       Y     = x.5^(x.6*inv(~x.2))
       z     = x.5^x.6
    
    6. ~x    = ~x.2
       Y     = x.5^inv((~x.2*x.6))
       z     = x.5^inv(x.6)
    
    7. ~x    = ~x.2
       Y     = x.5^(x.6*inv((~x.2*x.7)))
       z     = x.5^(x.6*inv(x.7))
  */

rule (modulo E) RevealKey:
   [ ] --[ Reveal( ) ]-> [ Out( shk ) ]

  /* has exactly the trivial AC variant */

lemma Accept_Secret:
  all-traces
  "∀ #i #j tid key.
    ((Accept( tid, key ) @ #i) ∧ (K( key ) @ #j)) ⇒
    (∃ #l. (Reveal( ) @ #l) ∧ (#l < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j tid key.
  (Accept( tid, key ) @ #i) ∧ (K( key ) @ #j)
 ∧
  ∀ #l. (Reveal( ) @ #l) ⇒ ¬(#l < #i)"
*/
simplify
solve( Step1( tid.1, A, B, ~x ) ▶₀ #i )
  case Step1
  solve( !KU( mac(shk, <Y, $B.1, $A.1>) ) @ #vk.2 )
    case Step1
    solve( !KU( g^(~x.3*~x.4) ) @ #vk.3 )
      case Step1_case_1
      by solve( !KU( ~x.6 ) @ #vk.4 )
    next
      case Step1_case_2
      by solve( !KU( ~x.6 ) @ #vk.4 )
    next
      case c_exp
      by solve( !KU( ~x.3 ) @ #vk.6 )
    qed
  next
    case c_mac
    solve( !KU( shk ) @ #vk.4 )
      case RevealKey
      by contradiction /* from formulas */
    qed
  qed
qed

lemma Accept_Secret_Counter:
  all-traces
  "∀ #i #j tid key. ((Accept( tid, key ) @ #i) ∧ (K( key ) @ #j)) ⇒ (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j tid key. (Accept( tid, key ) @ #i) ∧ (K( key ) @ #j)"
*/
simplify
solve( Step1( tid.1, A, B, ~x ) ▶₀ #i )
  case Step1
  solve( !KU( mac(shk, <Y, $B.1, $A.1>) ) @ #vk.2 )
    case c_mac
    solve( !KU( shk ) @ #vk.4 )
      case RevealKey
      solve( splitEqs(0) )
        case split_case_1
        solve( !KU( Y.1^~x.2 ) @ #vk.3 )
          case Step1
          SOLVED // trace found
        qed
      qed
    qed
  qed
qed













/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.11.0
Maude version 3.2.1
Git revision: d8e8266fc8aa702ff3c4d08608a7fbbe124eea65, branch: cyclic-squashed
Compiled at: 2024-11-27 09:37:37.786154 UTC
*/

end
/* Output

==============================================================================
summary of summaries:

analyzed: examples/cav13/DH_example.spthy

  output:          examples/cav13/DH_example.spthy.tmp
  processing time: 0.16s
  
  Accept_Secret (all-traces): verified (9 steps)
  Accept_Secret_Counter (all-traces): falsified - found trace (7 steps)

==============================================================================
*/
