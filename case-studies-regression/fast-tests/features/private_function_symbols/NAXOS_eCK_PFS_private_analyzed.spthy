theory NAXOS_eCK begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman
functions: fst/1, h1/1, h2/1, pair/2, sk/1[private,destructor], snd/1
equations: fst(<x.1, x.2>) = x.1, snd(<x.1, x.2>) = x.2







section{* NAXOS *}

rule (modulo E) Init_1:
   [ Fr( ~ex ) ]
  -->
   [ Init_1( ~ex, $A, $B ), !Ephk( ~ex, ~ex ), Out( 'g'^h1(<~ex, sk($A)>) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Init_2:
   [ Init_1( ~ex, $A, $B ), In( Y ) ]
  --[
  Accept( ~ex,
          h2(<Y^sk($A), 'g'^sk($B)^h1(<~ex, sk($A)>), Y^h1(<~ex, sk($A)>), $A, $B>)
  ),
  Sid( ~ex, <$A, $B, 'g'^h1(<~ex, sk($A)>), Y, 'Init'> )
  ]->
   [
   !Sessk( ~ex,
           h2(<Y^sk($A), 'g'^sk($B)^h1(<~ex, sk($A)>), Y^h1(<~ex, sk($A)>), $A, $B>)
   )
   ]

  /*
  rule (modulo AC) Init_2:
     [ Init_1( ~ex, $A, $B ), In( Y ) ]
    --[
    Accept( ~ex, h2(<z, 'g'^(h1(<~ex, sk($A)>)*sk($B)), z.1, $A, $B>) ),
    Sid( ~ex, <$A, $B, 'g'^h1(<~ex, sk($A)>), Y, 'Init'> )
    ]->
     [ !Sessk( ~ex, h2(<z, 'g'^(h1(<~ex, sk($A)>)*sk($B)), z.1, $A, $B>) ) ]
    variants (modulo AC)
     1. $A    = $x.24
        ~ex   = ~ex.3
        Y     = x.27^inv(sk($x.24))
        z     = x.27
        z.1   = x.27^(h1(<~ex.3, sk($x.24)>)*inv(sk($x.24)))
    
     2. Y     = DH_neutral
        z     = DH_neutral
        z.1   = DH_neutral
    
     3. $A    = $A.3
        ~ex   = ~ex.3
        Y     = Y.3
        z     = Y.3^sk($A.3)
        z.1   = Y.3^h1(<~ex.3, sk($A.3)>)
    
     4. $A    = $A.3
        ~ex   = ~ex.3
        Y     = x.22^x.23
        z     = x.22^(x.23*sk($A.3))
        z.1   = x.22^(x.23*h1(<~ex.3, sk($A.3)>))
    
     5. $A    = $x.24
        ~ex   = ~x.26
        Y     = x.27^inv((h1(<~x.26, sk($x.24)>)*sk($x.24)))
        z     = x.27^inv(h1(<~x.26, sk($x.24)>))
        z.1   = x.27^inv(sk($x.24))
    
     6. $A    = $x.24
        ~ex   = ~x.26
        Y     = x.27^inv(h1(<~x.26, sk($x.24)>))
        z     = x.27^(inv(h1(<~x.26, sk($x.24)>))*sk($x.24))
        z.1   = x.27
    
     7. $A    = $x.25
        ~ex   = ~ex.3
        Y     = x.28^(x.29*inv(sk($x.25)))
        z     = x.28^x.29
        z.1   = x.28^(x.29*h1(<~ex.3, sk($x.25)>)*inv(sk($x.25)))
    
     8. $A    = $x.25
        ~ex   = ~ex.3
        Y     = x.28^inv((x.29*sk($x.25)))
        z     = x.28^inv(x.29)
        z.1   = x.28^(h1(<~ex.3, sk($x.25)>)*inv((x.29*sk($x.25))))
    
     9. $A    = $x.25
        ~ex   = ~x.27
        Y     = x.28^inv((x.29*h1(<~x.27, sk($x.25)>)*sk($x.25)))
        z     = x.28^inv((x.29*h1(<~x.27, sk($x.25)>)))
        z.1   = x.28^inv((x.29*sk($x.25)))
    
    10. $A    = $x.25
        ~ex   = ~x.27
        Y     = x.28^(x.29*inv((h1(<~x.27, sk($x.25)>)*sk($x.25))))
        z     = x.28^(x.29*inv(h1(<~x.27, sk($x.25)>)))
        z.1   = x.28^(x.29*inv(sk($x.25)))
    
    11. $A    = $x.25
        ~ex   = ~x.27
        Y     = x.28^(x.29*inv(h1(<~x.27, sk($x.25)>)))
        z     = x.28^(x.29*inv(h1(<~x.27, sk($x.25)>))*sk($x.25))
        z.1   = x.28^x.29
    
    12. $A    = $x.25
        ~ex   = ~x.27
        Y     = x.28^inv((x.29*h1(<~x.27, sk($x.25)>)))
        z     = x.28^(inv((x.29*h1(<~x.27, sk($x.25)>)))*sk($x.25))
        z.1   = x.28^inv(x.29)
    
    13. $A    = $x.26
        ~ex   = ~ex.3
        Y     = x.29^(x.30*inv((x.31*sk($x.26))))
        z     = x.29^(x.30*inv(x.31))
        z.1   = x.29^(x.30*h1(<~ex.3, sk($x.26)>)*inv((x.31*sk($x.26))))
    
    14. $A    = $x.26
        ~ex   = ~x.28
        Y     = x.29^(x.30*inv((x.31*h1(<~x.28, sk($x.26)>)*sk($x.26))))
        z     = x.29^(x.30*inv((x.31*h1(<~x.28, sk($x.26)>))))
        z.1   = x.29^(x.30*inv((x.31*sk($x.26))))
    
    15. $A    = $x.26
        ~ex   = ~x.28
        Y     = x.29^(x.30*inv((x.31*h1(<~x.28, sk($x.26)>))))
        z     = x.29^(x.30*inv((x.31*h1(<~x.28, sk($x.26)>)))*sk($x.26))
        z.1   = x.29^(x.30*inv(x.31))
  */

rule (modulo E) Resp_1:
   [ Fr( ~ey ), In( X ) ]
  --[
  Accept( ~ey,
          h2(<'g'^sk($A)^h1(<~ey, sk($B)>), X^sk($B), X^h1(<~ey, sk($B)>), $A, $B>)
  ),
  Sid( ~ey, <$B, $A, 'g'^h1(<~ey, sk($B)>), X, 'Resp'> )
  ]->
   [
   Out( 'g'^h1(<~ey, sk($B)>) ), !Ephk( ~ey, ~ey ),
   !Sessk( ~ey,
           h2(<'g'^sk($A)^h1(<~ey, sk($B)>), X^sk($B), X^h1(<~ey, sk($B)>), $A, $B>)
   )
   ]

  /*
  rule (modulo AC) Resp_1:
     [ Fr( ~ey ), In( X ) ]
    --[
    Accept( ~ey, h2(<'g'^(h1(<~ey, sk($B)>)*sk($A)), z, z.1, $A, $B>) ),
    Sid( ~ey, <$B, $A, 'g'^h1(<~ey, sk($B)>), X, 'Resp'> )
    ]->
     [
     Out( 'g'^h1(<~ey, sk($B)>) ), !Ephk( ~ey, ~ey ),
     !Sessk( ~ey, h2(<'g'^(h1(<~ey, sk($B)>)*sk($A)), z, z.1, $A, $B>) )
     ]
    variants (modulo AC)
     1. $B    = $B.3
        ~ey   = ~ey.3
        X     = X.3
        z     = X.3^sk($B.3)
        z.1   = X.3^h1(<~ey.3, sk($B.3)>)
    
     2. $B    = $B.3
        ~ey   = ~ey.3
        X     = x.22^x.23
        z     = x.22^(x.23*sk($B.3))
        z.1   = x.22^(x.23*h1(<~ey.3, sk($B.3)>))
    
     3. $B    = $x.23
        ~ey   = ~ey.3
        X     = x.25^inv(sk($x.23))
        z     = x.25
        z.1   = x.25^(h1(<~ey.3, sk($x.23)>)*inv(sk($x.23)))
    
     4. $B    = $x.23
        ~ey   = ~x.24
        X     = x.25^inv(h1(<~x.24, sk($x.23)>))
        z     = x.25^(inv(h1(<~x.24, sk($x.23)>))*sk($x.23))
        z.1   = x.25
    
     5. $B    = $x.23
        ~ey   = ~x.24
        X     = x.25^inv((h1(<~x.24, sk($x.23)>)*sk($x.23)))
        z     = x.25^inv(h1(<~x.24, sk($x.23)>))
        z.1   = x.25^inv(sk($x.23))
    
     6. $B    = $x.24
        ~ey   = ~ey.3
        X     = x.26^inv((x.27*sk($x.24)))
        z     = x.26^inv(x.27)
        z.1   = x.26^(h1(<~ey.3, sk($x.24)>)*inv((x.27*sk($x.24))))
    
     7. $B    = $x.24
        ~ey   = ~ey.3
        X     = x.26^(x.27*inv(sk($x.24)))
        z     = x.26^x.27
        z.1   = x.26^(x.27*h1(<~ey.3, sk($x.24)>)*inv(sk($x.24)))
    
     8. $B    = $x.24
        ~ey   = ~x.25
        X     = x.26^inv((x.27*h1(<~x.25, sk($x.24)>)))
        z     = x.26^(inv((x.27*h1(<~x.25, sk($x.24)>)))*sk($x.24))
        z.1   = x.26^inv(x.27)
    
     9. $B    = $x.24
        ~ey   = ~x.25
        X     = x.26^inv((x.27*h1(<~x.25, sk($x.24)>)*sk($x.24)))
        z     = x.26^inv((x.27*h1(<~x.25, sk($x.24)>)))
        z.1   = x.26^inv((x.27*sk($x.24)))
    
    10. $B    = $x.24
        ~ey   = ~x.25
        X     = x.26^(x.27*inv(h1(<~x.25, sk($x.24)>)))
        z     = x.26^(x.27*inv(h1(<~x.25, sk($x.24)>))*sk($x.24))
        z.1   = x.26^x.27
    
    11. $B    = $x.24
        ~ey   = ~x.25
        X     = x.26^(x.27*inv((h1(<~x.25, sk($x.24)>)*sk($x.24))))
        z     = x.26^(x.27*inv(h1(<~x.25, sk($x.24)>)))
        z.1   = x.26^(x.27*inv(sk($x.24)))
    
    12. $B    = $x.25
        ~ey   = ~ey.3
        X     = x.27^(x.28*inv((x.29*sk($x.25))))
        z     = x.27^(x.28*inv(x.29))
        z.1   = x.27^(x.28*h1(<~ey.3, sk($x.25)>)*inv((x.29*sk($x.25))))
    
    13. $B    = $x.25
        ~ey   = ~x.26
        X     = x.27^(x.28*inv((x.29*h1(<~x.26, sk($x.25)>))))
        z     = x.27^(x.28*inv((x.29*h1(<~x.26, sk($x.25)>)))*sk($x.25))
        z.1   = x.27^(x.28*inv(x.29))
    
    14. $B    = $x.25
        ~ey   = ~x.26
        X     = x.27^(x.28*inv((x.29*h1(<~x.26, sk($x.25)>)*sk($x.25))))
        z     = x.27^(x.28*inv((x.29*h1(<~x.26, sk($x.25)>))))
        z.1   = x.27^(x.28*inv((x.29*sk($x.25))))
    
    15. X     = DH_neutral
        z     = DH_neutral
        z.1   = DH_neutral
  */

rule (modulo E) Sessk_reveal:
   [ !Sessk( ~s, k ) ] --[ RevealSessk( ~s ) ]-> [ Out( k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Ltk_reveal:
   [ ] --[ RevealLtk( $A ) ]-> [ Out( sk($A) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Ephk_reveal:
   [ !Ephk( ~s, ~ek ) ] --[ RevealEphk( ~s ) ]-> [ Out( ~ek ) ]

  /* has exactly the trivial AC variant */

lemma eCK_PFS_key_secrecy:
  all-traces
  "∀ #i1 #i2 #i3 test A B k sent recvd role.
    (((Accept( test, k ) @ #i1) ∧ (K( k ) @ #i2)) ∧
     (Sid( test, <A, B, sent, recvd, role> ) @ #i3)) ⇒
    ((((∃ #i3.1. RevealSessk( test ) @ #i3.1) ∨
       (∃ #i5 #i6. (RevealLtk( A ) @ #i5) ∧ (RevealEphk( test ) @ #i6))) ∨
      (∃ matchingSession #i3.1 matchingRole.
        ((Sid( matchingSession, <B, A, recvd, sent, matchingRole> ) @ #i3.1) ∧
         (¬(matchingRole = role))) ∧
        ((∃ #i5. RevealSessk( matchingSession ) @ #i5) ∨
         (∃ #i5 #i6.
           (RevealLtk( B ) @ #i5) ∧ (RevealEphk( matchingSession ) @ #i6))))) ∨
     ((¬(∃ matchingSession #i3.1 matchingRole.
          (Sid( matchingSession, <B, A, recvd, sent, matchingRole> ) @ #i3.1) ∧
          (¬(matchingRole = role)))) ∧
      (∃ #i5. (RevealLtk( B ) @ #i5) ∧ (#i5 < #i1))))"
/*
guarded formula characterizing all counter-examples:
"∃ #i1 #i2 #i3 test A B k sent recvd role.
  (Accept( test, k ) @ #i1) ∧
  (K( k ) @ #i2) ∧
  (Sid( test, <A, B, sent, recvd, role> ) @ #i3)
 ∧
  (∀ #i3.1. (RevealSessk( test ) @ #i3.1) ⇒ ⊥) ∧
  (∀ #i5 #i6. (RevealLtk( A ) @ #i5) ∧ (RevealEphk( test ) @ #i6) ⇒ ⊥) ∧
  (∀ matchingSession #i3.1 matchingRole.
    (Sid( matchingSession, <B, A, recvd, sent, matchingRole> ) @ #i3.1)
   ⇒
    ((matchingRole = role) ∨
     ((∀ #i5. (RevealSessk( matchingSession ) @ #i5) ⇒ ⊥) ∧
      (∀ #i5 #i6.
        (RevealLtk( B ) @ #i5) ∧ (RevealEphk( matchingSession ) @ #i6) ⇒ ⊥)))) ∧
  (((∃ matchingSession #i3.1 matchingRole.
      (Sid( matchingSession, <B, A, recvd, sent, matchingRole> ) @ #i3.1)
     ∧
      ¬(matchingRole = role)) ∨
    (∀ #i5. (RevealLtk( B ) @ #i5) ⇒ ¬(#i5 < #i1))))"
*/
simplify
solve( (∃ matchingSession #i3 matchingRole.
         (Sid( matchingSession, <B, A, recvd, sent, matchingRole> ) @ #i3)
        ∧
         ¬(matchingRole = role))  ∥
       (∀ #i5. (RevealLtk( B ) @ #i5) ⇒ ¬(#i5 < #i1)) )
  case case_2
  solve( Accept( test, x ) @ #i1 )
    case Init_2
    solve( Init_1( ~ex, $A.1, $B.1 ) ▶₀ #i1 )
      case Init_1
      solve( Sid( ~ex, <A, B, sent, recvd, role> ) @ #i3 )
        case Init_2
        solve( Init_1( ~ex.1, $A.2, $B.2 ) ▶₀ #i3 )
          case Init_1
          solve( !KU( h2(<z.2, 'g'^(h1(<~ex.1, sk($A.2)>)*sk($B.2)), z.3, $A.2, 
                          $B.2>)
                 ) @ #vk )
            case c_h2
            solve( !KU( 'g'^(h1(<~ex.1, sk($A.2)>)*sk($B.2)) ) @ #vk.6 )
              case Init_1
              solve( !KU( sk($B.3) ) @ #vk.12 )
                case Ltk_reveal
                solve( splitEqs(0) )
                  case split_case_01
                  solve( !KU( Y.2^sk($A.4) ) @ #vk.4 )
                    case c_exp
                    solve( !KU( sk($A.4) ) @ #vk.14 )
                      case Ltk_reveal
                      solve( !KU( Y.2^h1(<~ex.3, sk($A.4)>) ) @ #vk.8 )
                        case Init_1
                        SOLVED // trace found
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed













/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.11.0
Maude version 3.2.1
Git revision: d8e8266fc8aa702ff3c4d08608a7fbbe124eea65, branch: cyclic-squashed
Compiled at: 2024-11-27 09:37:37.786154 UTC
*/

end
/* Output

==============================================================================
summary of summaries:

analyzed: examples/features//private_function_symbols/NAXOS_eCK_PFS_private.spthy

  output:          examples/features//private_function_symbols/NAXOS_eCK_PFS_private.spthy.tmp
  processing time: 0.80s
  
  eCK_PFS_key_secrecy (all-traces): falsified - found trace (14 steps)

==============================================================================
*/
