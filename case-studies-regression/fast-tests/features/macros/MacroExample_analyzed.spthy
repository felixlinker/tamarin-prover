theory MacroExemple begin

// Function signature and definition of the equational theory E

functions: adec/2, aenc/2, fst/1, h/1, pair/2, pk/1, snd/1
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2









macros:
    encrypt( x, y ) = aenc(x,y)
    decrypt( x, y ) = adec(x,y)
    hashdec( x, y ) = h(decrypt(x,y))

rule (modulo E) Register_pk:
   [ Fr( ~ltk ) ] --> [ !Ltk( $A, ~ltk ), !Pk( $A, pk(~ltk) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Get_pk:
   [ !Pk( A, pubkey ) ] --> [ Out( pubkey ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_ltk:
   [ !Ltk( A, ltk ) ] --[ LtkReveal( A ) ]-> [ Out( ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Client_1:
   [ Fr( ~k ), !Pk( $S, pkS ) ]
  -->
   [ Client_1( $S, ~k ), Out( encrypt(~k, pkS) ) ]

  /*
  rule (modulo AC) Client_1:
     [ Fr( ~k ), !Pk( $S, pkS ) ]
    -->
     [ Client_1( $S, ~k ), Out( aenc(~k, pkS) ) ]
  */

rule (modulo E) Client_2:
   [ Client_1( S, k ), In( h(k) ) ] --[ SessKeyC( S, k ) ]-> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Serv_1:
   [ !Ltk( $S, ~ltkS ), In( request ) ]
  --[ AnswerRequest( $S, decrypt(request, ~ltkS) ) ]->
   [ Out( hashdec(request, ~ltkS) ) ]

  /*
  rule (modulo AC) Serv_1:
     [ !Ltk( $S, ~ltkS ), In( request ) ]
    --[ AnswerRequest( $S, z ) ]->
     [ Out( h(z) ) ]
    variants (modulo AC)
    1. ~ltkS = ~x
       request
             = aenc(x.1, pk(~x))
       z     = x.1
    
    2. ~ltkS = ~ltkS.2
       request
             = request.2
       z     = adec(request.2, ~ltkS.2)
  */

lemma Client_session_key_secrecy:
  all-traces
  "¬(∃ S k #i #j.
      ((SessKeyC( S, k ) @ #i) ∧ (K( k ) @ #j)) ∧
      (¬(∃ #r. LtkReveal( S ) @ #r)))"
/*
guarded formula characterizing all counter-examples:
"∃ S k #i #j.
  (SessKeyC( S, k ) @ #i) ∧ (K( k ) @ #j)
 ∧
  ∀ #r. (LtkReveal( S ) @ #r) ⇒ ⊥"
*/
simplify
solve( Client_1( S.1, x ) ▶₀ #i )
  case Client_1
  solve( !KU( ~k.2 ) @ #vk.1 )
    case Client_1
    solve( !KU( ~ltk.1 ) @ #vk.2 )
      case Reveal_ltk
      by contradiction /* from formulas */
    qed
  qed
qed

lemma Client_auth:
  all-traces
  "∀ S k #i.
    (SessKeyC( S, k ) @ #i) ⇒
    ((∃ #a. AnswerRequest( S, k ) @ #a) ∨
     (∃ #r. (LtkReveal( S ) @ #r) ∧ (#r < #i)))"
/*
guarded formula characterizing all counter-examples:
"∃ S k #i.
  (SessKeyC( S, k ) @ #i)
 ∧
  (∀ #a. (AnswerRequest( S, k ) @ #a) ⇒ ⊥) ∧
  (∀ #r. (LtkReveal( S ) @ #r) ⇒ ¬(#r < #i))"
*/
simplify
solve( Client_1( S.1, k.1 ) ▶₀ #i )
  case Client_1
  solve( !KU( h(~k.2) ) @ #vk )
    case Serv_1
    solve( !KU( aenc(~k.3, pk(~ltkS)) ) @ #vk.1 )
      case Client_1
      by contradiction /* from formulas */
    next
      case c_aenc
      solve( !KU( ~k.3 ) @ #vk.2 )
        case Client_1
        solve( !KU( ~ltk.1 ) @ #vk.4 )
          case Reveal_ltk
          by contradiction /* from formulas */
        qed
      qed
    qed
  next
    case c_h
    solve( !KU( ~k.2 ) @ #vk.1 )
      case Client_1
      solve( !KU( ~ltk.1 ) @ #vk.2 )
        case Reveal_ltk
        by contradiction /* from formulas */
      qed
    qed
  qed
qed

lemma Client_auth_injective:
  all-traces
  "∀ S k #i.
    (SessKeyC( S, k ) @ #i) ⇒
    ((∃ #a.
       (AnswerRequest( S, k ) @ #a) ∧
       (∀ #j. (SessKeyC( S, k ) @ #j) ⇒ (#i = #j))) ∨
     (∃ #r. (LtkReveal( S ) @ #r) ∧ (#r < #i)))"
/*
guarded formula characterizing all counter-examples:
"∃ S k #i.
  (SessKeyC( S, k ) @ #i)
 ∧
  (∀ #a.
    (AnswerRequest( S, k ) @ #a)
   ⇒
    ∃ #j. (SessKeyC( S, k ) @ #j) ∧ ¬(#i = #j)) ∧
  (∀ #r. (LtkReveal( S ) @ #r) ⇒ ¬(#r < #i))"
*/
simplify
solve( Client_1( S.1, k.1 ) ▶₀ #i )
  case Client_1
  solve( !KU( h(~k.2) ) @ #vk )
    case Serv_1
    solve( !KU( aenc(~k.3, pk(~ltkS)) ) @ #vk.1 )
      case Client_1
      solve( (#i < #j)  ∥ (#j < #i) )
        case case_1
        solve( Client_1( $S.4, ~k.3 ) ▶₀ #j )
          case Client_1
          by contradiction /* cyclic */
        qed
      next
        case case_2
        solve( Client_1( $S.4, ~k.3 ) ▶₀ #j )
          case Client_1
          by contradiction /* cyclic */
        qed
      qed
    next
      case c_aenc
      solve( !KU( ~k.3 ) @ #vk.2 )
        case Client_1
        solve( !KU( ~ltk.1 ) @ #vk.4 )
          case Reveal_ltk
          by contradiction /* from formulas */
        qed
      qed
    qed
  next
    case c_h
    solve( !KU( ~k.2 ) @ #vk.1 )
      case Client_1
      solve( !KU( ~ltk.1 ) @ #vk.2 )
        case Reveal_ltk
        by contradiction /* from formulas */
      qed
    qed
  qed
qed

lemma Client_session_key_honest_setup:
  exists-trace
  "∃ S k #i. (SessKeyC( S, k ) @ #i) ∧ (¬(∃ #r. LtkReveal( S ) @ #r))"
/*
guarded formula characterizing all satisfying traces:
"∃ S k #i. (SessKeyC( S, k ) @ #i) ∧ ∀ #r. (LtkReveal( S ) @ #r) ⇒ ⊥"
*/
simplify
solve( Client_1( S.1, k.1 ) ▶₀ #i )
  case Client_1
  solve( !KU( h(~k.2) ) @ #vk )
    case Serv_1
    solve( !KU( aenc(~k.3, pk(~ltkS)) ) @ #vk.1 )
      case Client_1
      SOLVED // trace found
    qed
  qed
qed















/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.11.0
Maude version 3.2.1
Git revision: d8e8266fc8aa702ff3c4d08608a7fbbe124eea65, branch: cyclic-squashed
Compiled at: 2024-11-27 09:37:37.786154 UTC
*/

end
/* Output

==============================================================================
summary of summaries:

analyzed: examples/features//macros/MacroExample.spthy

  output:          examples/features//macros/MacroExample.spthy.tmp
  processing time: 0.16s
  
  Client_session_key_secrecy (all-traces): verified (5 steps)
  Client_auth (all-traces): verified (11 steps)
  Client_auth_injective (all-traces): verified (15 steps)
  Client_session_key_honest_setup (exists-trace): verified (5 steps)

==============================================================================
*/
