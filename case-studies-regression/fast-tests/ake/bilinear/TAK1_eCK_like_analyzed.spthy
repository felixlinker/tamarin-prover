theory TAK1 begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman, bilinear-pairing, multiset
functions: fst/1, h/1, kdf/1, pair/2, snd/1, tag/1
equations: fst(<x.1, x.2>) = x.1, snd(<x.1, x.2>) = x.2





section{* The TAK1 Protocol. *}





rule (modulo E) Register_pk:
   [ Fr( ~ea ) ]
  -->
   [ !Ltk( $A, ~ea ), !Pk( $A, pmult(~ea, 'P') ), Out( pmult(~ea, 'P') ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_ltk:
   [ !Ltk( $A, ~ea ) ] --[ LtkRev( $A ) ]-> [ Out( ~ea ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_ephk:
   [ !EphKey( ~ek ) ] --[ EphkRev( ~ek ) ]-> [ Out( ~ek ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_sessk:
   [ !SessKey( ~sid, kdf(sessKey) ) ]
  --[ SesskRev( ~sid ) ]->
   [ Out( kdf(sessKey) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Proto1:
   [ Fr( ~ex ) ]
  --[ Origin( ~ex, pmult(~ex, 'P') ), Participants( ($A++$B++$C) ) ]->
   [ PState1( ~ex, $A, $B, $C ), Out( pmult(~ex, 'P') ), !EphKey( ~ex ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Proto2:
   [ PState1( ~ex, $A, $B, $C ), In( XB ), In( XC ) ]
  -->
   [ PState2( ~ex, $A, $B, $C, tag(XB), tag(XC), em(XB, XC) ) ]

  /*
  rule (modulo AC) Proto2:
     [ PState1( ~ex, $A, $B, $C ), In( XB ), In( XC ) ]
    -->
     [ PState2( ~ex, $A, $B, $C, tag(XB), tag(XC), z ) ]
    variants (modulo AC)
     1. XB    = XB.2
        XC    = pmult(x, x.1)
        z     = em(x.1, XB.2)^x
    
     2. XB    = pmult(x, x.1)
        XC    = XC.2
        z     = em(x.1, XC.2)^x
    
     3. XB    = pmult(x, x.1)
        XC    = pmult((x.2*inv(x)), x.3)
        z     = em(x.1, x.3)^x.2
    
     4. XB    = pmult(inv(x), x.1)
        XC    = pmult((x*x.2), x.3)
        z     = em(x.1, x.3)^x.2
    
     5. XB    = pmult(x, x.1)
        XC    = pmult(inv((x*x.2)), x.3)
        z     = em(x.1, x.3)^inv(x.2)
    
     6. XB    = pmult(inv(x), x.1)
        XC    = pmult(inv(x.2), x.3)
        z     = em(x.1, x.3)^inv((x*x.2))
    
     7. XB    = pmult(x, x.1)
        XC    = pmult(x.2, x.3)
        z     = em(x.1, x.3)^(x*x.2)
    
     8. XB    = pmult(x, x.1)
        XC    = pmult((x.2*inv((x*x.3))), x.4)
        z     = em(x.1, x.4)^(x.2*inv(x.3))
    
     9. XB    = pmult(inv(x), x.1)
        XC    = pmult((x.2*inv(x.3)), x.4)
        z     = em(x.1, x.4)^(x.2*inv((x*x.3)))
    
    10. XB    = pmult((x*inv(x.1)), x.2)
        XC    = pmult(x.1, x.3)
        z     = em(x.2, x.3)^x
    
    11. XB    = pmult((x*x.1), x.2)
        XC    = pmult(inv(x), x.3)
        z     = em(x.2, x.3)^x.1
    
    12. XB    = pmult(inv((x*x.1)), x.2)
        XC    = pmult(x.1, x.3)
        z     = em(x.2, x.3)^inv(x)
    
    13. XB    = pmult((x*inv(x.1)), x.2)
        XC    = pmult((x.1*x.3*inv(x)), x.4)
        z     = em(x.2, x.4)^x.3
    
    14. XB    = pmult((x*inv(x.1)), x.2)
        XC    = pmult((x.1*inv((x*x.3))), x.4)
        z     = em(x.2, x.4)^inv(x.3)
    
    15. XB    = pmult(inv((x*x.1)), x.2)
        XC    = pmult((x*inv(x.3)), x.4)
        z     = em(x.2, x.4)^inv((x.1*x.3))
    
    16. XB    = pmult((x*inv(x.1)), x.2)
        XC    = pmult(inv((x*x.3)), x.4)
        z     = em(x.2, x.4)^inv((x.1*x.3))
    
    17. XB    = pmult((x*inv(x.1)), x.2)
        XC    = pmult((x.1*x.3), x.4)
        z     = em(x.2, x.4)^(x*x.3)
    
    18. XB    = pmult((x*inv(x.1)), x.2)
        XC    = pmult(inv(x.3), x.4)
        z     = em(x.2, x.4)^(x*inv((x.1*x.3)))
    
    19. XB    = pmult((x*x.1), x.2)
        XC    = pmult((x.3*inv(x)), x.4)
        z     = em(x.2, x.4)^(x.1*x.3)
    
    20. XB    = pmult((x*x.1), x.2)
        XC    = pmult(inv((x*x.3)), x.4)
        z     = em(x.2, x.4)^(x.1*inv(x.3))
    
    21. XB    = pmult(inv((x*x.1)), x.2)
        XC    = pmult((x*x.3), x.4)
        z     = em(x.2, x.4)^(x.3*inv(x.1))
    
    22. XB    = pmult((x*inv(x.1)), x.2)
        XC    = pmult((x.3*inv(x.4)), x.5)
        z     = em(x.2, x.5)^(x*x.3*inv((x.1*x.4)))
    
    23. XB    = pmult((x*x.1), x.2)
        XC    = pmult((x.3*inv((x*x.4))), x.5)
        z     = em(x.2, x.5)^(x.1*x.3*inv(x.4))
    
    24. XB    = pmult((x*inv(x.1)), x.2)
        XC    = pmult((x.1*x.3*inv((x*x.4))), x.5)
        z     = em(x.2, x.5)^(x.3*inv(x.4))
    
    25. XB    = pmult(inv((x*x.1)), x.2)
        XC    = pmult((x*x.3*inv(x.4)), x.5)
        z     = em(x.2, x.5)^(x.3*inv((x.1*x.4)))
    
    26. XB    = pmult((x*inv(x.1)), x.2)
        XC    = pmult((x.3*inv((x*x.4))), x.5)
        z     = em(x.2, x.5)^(x.3*inv((x.1*x.4)))
    
    27. XB    = pmult((x*x.1*inv(x.2)), x.3)
        XC    = pmult((x.2*inv(x.1)), x.4)
        z     = em(x.3, x.4)^x
    
    28. XB    = pmult((x*inv((x.1*x.2))), x.3)
        XC    = pmult((x.2*inv(x)), x.4)
        z     = em(x.3, x.4)^inv(x.1)
    
    29. XB    = pmult((x*inv((x.1*x.2))), x.3)
        XC    = pmult(x.2, x.4)
        z     = em(x.3, x.4)^(x*inv(x.1))
    
    30. XB    = pmult((x*inv((x.1*x.2))), x.3)
        XC    = pmult((x.1*inv((x*x.4))), x.5)
        z     = em(x.3, x.5)^inv((x.2*x.4))
    
    31. XB    = pmult((x*inv((x.1*x.2))), x.3)
        XC    = pmult((x.1*x.4), x.5)
        z     = em(x.3, x.5)^(x*x.4*inv(x.2))
    
    32. XB    = pmult((x*x.1*inv(x.2)), x.3)
        XC    = pmult(inv((x.1*x.4)), x.5)
        z     = em(x.3, x.5)^(x*inv((x.2*x.4)))
    
    33. XB    = pmult((x*inv((x.1*x.2))), x.3)
        XC    = pmult((x.1*inv(x.4)), x.5)
        z     = em(x.3, x.5)^(x*inv((x.2*x.4)))
    
    34. XB    = pmult((x*x.1*inv(x.2)), x.3)
        XC    = pmult((x.2*x.4*inv(x)), x.5)
        z     = em(x.3, x.5)^(x.1*x.4)
    
    35. XB    = pmult((x*x.1*inv(x.2)), x.3)
        XC    = pmult((x.2*inv((x*x.4))), x.5)
        z     = em(x.3, x.5)^(x.1*inv(x.4))
    
    36. XB    = pmult((x*inv((x.1*x.2))), x.3)
        XC    = pmult((x.1*x.4*inv(x)), x.5)
        z     = em(x.3, x.5)^(x.4*inv(x.2))
    
    37. XB    = pmult((x*inv((x.1*x.2))), x.3)
        XC    = pmult((x.1*x.4*inv(x.5)), x.6)
        z     = em(x.3, x.6)^(x*x.4*inv((x.2*x.5)))
    
    38. XB    = pmult((x*x.1*inv(x.2)), x.3)
        XC    = pmult((x.2*x.4*inv((x*x.5))), x.6)
        z     = em(x.3, x.6)^(x.1*x.4*inv(x.5))
    
    39. XB    = pmult((x*x.1*inv(x.2)), x.3)
        XC    = pmult((x.4*inv((x*x.5))), x.6)
        z     = em(x.3, x.6)^(x.1*x.4*inv((x.2*x.5)))
    
    40. XB    = pmult((x*inv((x.1*x.2))), x.3)
        XC    = pmult((x.1*x.4*inv((x*x.5))), x.6)
        z     = em(x.3, x.6)^(x.4*inv((x.2*x.5)))
    
    41. XB    = pmult((x*x.1*inv((x.2*x.3))), x.4)
        XC    = pmult((x.3*inv(x.1)), x.5)
        z     = em(x.4, x.5)^(x*inv(x.2))
    
    42. XB    = pmult((x*x.1*inv((x.2*x.3))), x.4)
        XC    = pmult((x.2*x.5*inv(x)), x.6)
        z     = em(x.4, x.6)^(x.1*x.5*inv(x.3))
    
    43. XB    = pmult((x*x.1*inv((x.2*x.3))), x.4)
        XC    = pmult((x.2*inv((x*x.5))), x.6)
        z     = em(x.4, x.6)^(x.1*inv((x.3*x.5)))
    
    44. XB    = pmult((x*x.1*inv((x.2*x.3))), x.4)
        XC    = pmult((x.2*x.5*inv((x*x.6))), x.7)
        z     = em(x.4, x.7)^(x.1*x.5*inv((x.3*x.6)))
    
    45. XB    = pmult(x, x.1)
        XC    = pmult(inv(x), x.2)
        z     = em(x.1, x.2)
    
    46. XB    = pmult(inv(x), x.1)
        XC    = pmult(x, x.2)
        z     = em(x.1, x.2)
    
    47. XB    = XB.2
        XC    = XC.2
        z     = em(XB.2, XC.2)
    
    48. XB    = pmult((x*inv(x.1)), x.2)
        XC    = pmult((x.1*inv(x)), x.3)
        z     = em(x.2, x.3)
  */

rule (modulo E) Proto3:
   [
   PState2( ~ex, $A, $B, $C, tag(XB), tag(XC), emXBXC ), !Ltk( $A, ~ea ),
   !Pk( $B, pmult(~eb, 'P') ), !Pk( $C, pmult(~ec, 'P') )
   ]
  --[
  Accept( ~ex, $A, $B, $C, pmult(~ex, 'P'), tag(XB), tag(XC),
          kdf(<emXBXC^~ex, em(pmult(~eb, 'P'), pmult(~ec, 'P'))^~ea, ($A++$B++$C), 
               (tag(XB)++tag(XC)++tag(pmult(~ex, 'P')))>)
  ),
  Match( ~ex, <(tag(XB)++tag(XC)++tag(pmult(~ex, 'P'))), ($A++$B++$C)> ),
  Sid( ~ex, <(tag(XB)++tag(XC)++tag(pmult(~ex, 'P'))), ($A++$B++$C)> )
  ]->
   [
   !SessKey( ~ex,
             kdf(<emXBXC^~ex, em(pmult(~eb, 'P'), pmult(~ec, 'P'))^~ea, ($A++$B++$C), 
                  (tag(XB)++tag(XC)++tag(pmult(~ex, 'P')))>)
   )
   ]

  /*
  rule (modulo AC) Proto3:
     [
     PState2( ~ex, $A, $B, $C, tag(XB), tag(XC), emXBXC ), !Ltk( $A, ~ea ),
     !Pk( $B, pmult(~x, 'P') ), !Pk( $C, pmult(~x.1, 'P') )
     ]
    --[
    Accept( ~ex, $A, $B, $C, pmult(~ex, 'P'), tag(XB), tag(XC),
            kdf(<z, em('P', 'P')^(~ea*~x*~x.1), ($A++$B++$C), 
                 (tag(XB)++tag(XC)++tag(pmult(~ex, 'P')))>)
    ),
    Match( ~ex, <(tag(XB)++tag(XC)++tag(pmult(~ex, 'P'))), ($A++$B++$C)> ),
    Sid( ~ex, <(tag(XB)++tag(XC)++tag(pmult(~ex, 'P'))), ($A++$B++$C)> )
    ]->
     [
     !SessKey( ~ex,
               kdf(<z, em('P', 'P')^(~ea*~x*~x.1), ($A++$B++$C), 
                    (tag(XB)++tag(XC)++tag(pmult(~ex, 'P')))>)
     )
     ]
    variants (modulo AC)
    1. ~ex   = ~ex.3
       emXBXC
             = emXBXC.3
       z     = emXBXC.3^~ex.3
    
    2. ~ex   = ~ex.3
       emXBXC
             = x.20^x.21
       z     = x.20^(~ex.3*x.21)
    
    3. ~ex   = ~x.22
       emXBXC
             = x.25^inv(~x.22)
       z     = x.25
    
    4. ~ex   = ~x.23
       emXBXC
             = x.26^inv((~x.23*x.27))
       z     = x.26^inv(x.27)
    
    5. ~ex   = ~x.23
       emXBXC
             = x.26^(x.27*inv(~x.23))
       z     = x.26^x.27
    
    6. ~ex   = ~x.24
       emXBXC
             = x.27^(x.28*inv((~x.24*x.29)))
       z     = x.27^(x.28*inv(x.29))
    
    7. emXBXC
             = DH_neutral
       z     = DH_neutral
  */

lemma session_key_establish:
  exists-trace
  "∃ A B C XA XB XC sa sb sc #ia #ib #ic k.
    ((((((((Accept( sa, A, B, C, XA, tag(XB), tag(XC), k ) @ #ia) ∧
           (Accept( sb, B, A, C, XB, tag(XA), tag(XC), k ) @ #ib)) ∧
          (Accept( sc, C, A, B, XC, tag(XA), tag(XB), k ) @ #ic)) ∧
         (¬(A = B))) ∧
        (¬(B = C))) ∧
       (¬(A = C))) ∧
      (¬(∃ #j. LtkRev( A ) @ #j))) ∧
     (¬(∃ #j. LtkRev( B ) @ #j))) ∧
    (¬(∃ #j. LtkRev( C ) @ #j))"
/*
guarded formula characterizing all satisfying traces:
"∃ A B C XA XB XC sa sb sc #ia #ib #ic k.
  (Accept( sa, A, B, C, XA, tag(XB), tag(XC), k ) @ #ia) ∧
  (Accept( sb, B, A, C, XB, tag(XA), tag(XC), k ) @ #ib) ∧
  (Accept( sc, C, A, B, XC, tag(XA), tag(XB), k ) @ #ic)
 ∧
  (¬(A = B)) ∧
  (¬(B = C)) ∧
  (¬(A = C)) ∧
  (∀ #j. (LtkRev( A ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (LtkRev( B ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (LtkRev( C ) @ #j) ⇒ ⊥)"
*/
simplify
  case 17
  solve( PState2( ~ex, $B.3, $C.3, $A.3, tag(pmult(~ex.1, 'P')),
                  tag(pmult(~ex.2, 'P')), emXBXC
         ) ▶₀ #ia )
    case Proto2
    solve( !Ltk( $B.3, ~ea.4 ) ▶₁ #ia )
      case Register_pk
      solve( !Pk( $C.3, pmult(~x.8, 'P') ) ▶₂ #ia )
        case Register_pk
        solve( !Pk( $A.3, pmult(~ea.5, 'P') ) ▶₃ #ia )
          case Register_pk
          solve( PState2( ~ex.9, $C.3, $B.3, $A.3, tag(pmult(~ex.11, 'P')),
                          tag(pmult(~ex.10, 'P')), em('P', 'P')^(~ex.10*~ex.11)
                 ) ▶₀ #ib )
            case Proto2
            solve( !Ltk( $C.3, ~x.8 ) ▶₁ #ib )
              case Register_pk
              solve( !Pk( $B.3, pmult(~ea.4, 'P') ) ▶₂ #ib )
                case Register_pk
                solve( !Pk( $A.3, pmult(~ea.5, 'P') ) ▶₃ #ib )
                  case Register_pk
                  solve( PState2( ~ex.10, $A.3, $B.3, $C.3, tag(pmult(~ex.11, 'P')),
                                  tag(pmult(~ex.9, 'P')), em('P', 'P')^(~ex.9*~ex.11)
                         ) ▶₀ #ic )
                    case Proto2
                    solve( !Ltk( $A.3, ~ea.5 ) ▶₁ #ic )
                      case Register_pk
                      solve( !Pk( $B.3, pmult(~ea.4, 'P') ) ▶₂ #ic )
                        case Register_pk
                        solve( !Pk( $C.3, pmult(~x.8, 'P') ) ▶₃ #ic )
                          case Register_pk
                          solve( !KU( pmult(~ex.9, 'P') ) @ #vk.5 )
                            case Proto1
                            solve( !KU( pmult(~ex.10, 'P') ) @ #vk.3 )
                              case Proto1
                              solve( !KU( pmult(~ex.11, 'P') ) @ #vk.4 )
                                case Proto1
                                SOLVED // trace found
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma Session_Key_Secrecy:
  all-traces
  "∀ stest A B C XA XB XC sessKey sessString #i #j.
    (((Accept( stest, A, B, C, XA, tag(XB), tag(XC), sessKey ) @ #i) ∧
      (K( sessKey ) @ #j)) ∧
     (Match( stest, sessString ) @ #i)) ⇒
    (((∃ #m #n smatch.
        (Sid( smatch, sessString ) @ #m) ∧ (SesskRev( smatch ) @ #n)) ∨
      (((¬(∃ #k spartner. Origin( spartner, XC ) @ #k)) ∨
        (¬(∃ #k spartner. Origin( spartner, XB ) @ #k))) ∧
       (((∃ #m. LtkRev( A ) @ #m) ∨ (∃ #m. LtkRev( B ) @ #m)) ∨
        (∃ #m. LtkRev( C ) @ #m)))) ∨
     (∃ #k #l spartner1 spartner2.
       ((Origin( spartner1, XB ) @ #k) ∧ (Origin( spartner2, XC ) @ #l)) ∧
       ((((∃ #v1. LtkRev( B ) @ #v1) ∨ (∃ #v1. LtkRev( C ) @ #v1)) ∧
         ((∃ #v2. EphkRev( spartner1 ) @ #v2) ∨
          (∃ #v2. EphkRev( spartner2 ) @ #v2))) ∨
        ((∃ #v1. LtkRev( A ) @ #v1) ∧ (∃ #v2. EphkRev( stest ) @ #v2)))))"
/*
guarded formula characterizing all counter-examples:
"∃ stest A B C XA XB XC sessKey sessString #i #j.
  (Accept( stest, A, B, C, XA, tag(XB), tag(XC), sessKey ) @ #i) ∧
  (K( sessKey ) @ #j) ∧
  (Match( stest, sessString ) @ #i)
 ∧
  (∀ #m #n smatch.
    (Sid( smatch, sessString ) @ #m) ∧ (SesskRev( smatch ) @ #n) ⇒ ⊥) ∧
  ((((∃ #k spartner. (Origin( spartner, XC ) @ #k)) ∧
     (∃ #k spartner. (Origin( spartner, XB ) @ #k))) ∨
    ((∀ #m. (LtkRev( A ) @ #m) ⇒ ⊥) ∧
     (∀ #m. (LtkRev( B ) @ #m) ⇒ ⊥) ∧
     (∀ #m. (LtkRev( C ) @ #m) ⇒ ⊥)))) ∧
  (∀ #k #l spartner1 spartner2.
    (Origin( spartner1, XB ) @ #k) ∧ (Origin( spartner2, XC ) @ #l)
   ⇒
    ((((∀ #v1. (LtkRev( B ) @ #v1) ⇒ ⊥) ∧ (∀ #v1. (LtkRev( C ) @ #v1) ⇒ ⊥)) ∨
      ((∀ #v2. (EphkRev( spartner1 ) @ #v2) ⇒ ⊥) ∧
       (∀ #v2. (EphkRev( spartner2 ) @ #v2) ⇒ ⊥)))) ∧
    (((∀ #v1. (LtkRev( A ) @ #v1) ⇒ ⊥) ∨
      (∀ #v2. (EphkRev( stest ) @ #v2) ⇒ ⊥))))"
*/
simplify
solve( ((∃ #k spartner. (Origin( spartner, XC.1 ) @ #k)) ∧
        (∃ #k spartner. (Origin( spartner, XB.1 ) @ #k)))  ∥
       ((∀ #m. (LtkRev( $A.1 ) @ #m) ⇒ ⊥) ∧
        (∀ #m. (LtkRev( $B.1 ) @ #m) ⇒ ⊥) ∧
        (∀ #m. (LtkRev( $C.1 ) @ #m) ⇒ ⊥)) )
  case case_1
  solve( ((∀ #v1. (LtkRev( $B.1 ) @ #v1) ⇒ ⊥) ∧
          (∀ #v1. (LtkRev( $C.1 ) @ #v1) ⇒ ⊥))  ∥
         ((∀ #v2. (EphkRev( ~ex.2 ) @ #v2) ⇒ ⊥) ∧
          (∀ #v2. (EphkRev( ~ex.1 ) @ #v2) ⇒ ⊥)) )
    case case_1
    solve( (∀ #v1. (LtkRev( $A.1 ) @ #v1) ⇒ ⊥)  ∥
           (∀ #v2. (EphkRev( ~ex ) @ #v2) ⇒ ⊥) )
      case case_2
      solve( PState2( ~ex, $A.1, $B.1, $C.1, tag(pmult(~ex.2, 'P')),
                      tag(pmult(~ex.1, 'P')), emXBXC
             ) ▶₀ #i )
        case Proto2
        solve( !Ltk( $A.1, ~ea ) ▶₁ #i )
          case Register_pk
          solve( !Pk( $B.1, pmult(~x, 'P') ) ▶₂ #i )
            case Register_pk
            solve( !Pk( $C.1, pmult(~x.1, 'P') ) ▶₃ #i )
              case Register_pk
              solve( !KU( kdf(<em('P', 'P')^(~ex.5*~ex.6*~ex.7), 
                               em('P', 'P')^(~ea*~x*~x.1), ($A.1++$B.1++$C.1), 
                               (tag(pmult(~ex.5, 'P'))++tag(pmult(~ex.6, 'P'))++tag(pmult(~ex.7, 'P')))
                              >)
                     ) @ #vk )
                case c_kdf
                solve( !KU( tag(pmult(~ex.5, 'P')) ) @ #vk.13 )
                  case c_tag
                  solve( !KU( tag(pmult(~ex.6, 'P')) ) @ #vk.14 )
                    case c_tag
                    solve( !KU( tag(pmult(~ex.7, 'P')) ) @ #vk.15 )
                      case c_tag
                      solve( !KU( em('P', 'P')^(~ex.5*~ex.6*~ex.7) ) @ #vk.4 )
                        case Proto1_case_3
                        solve( !KU( ~ex.9 ) @ #vk.21 )
                          case Reveal_ephk
                          solve( !KU( ~ex.10 ) @ #vk.22 )
                            case Reveal_ephk
                            solve( !KU( em('P', 'P')^(~ea*~x*~x.1) ) @ #vk.6 )
                              case Register_pk_case_4
                              solve( !KU( ~ea.1 ) @ #vk.29 )
                                case Reveal_ltk
                                solve( !KU( pmult(~ex.9, 'P') ) @ #vk.17 )
                                  case Proto1
                                  solve( !KU( pmult(~ex.10, 'P') ) @ #vk.18 )
                                    case Proto1
                                    solve( !KU( pmult(~ex.8, 'P') ) @ #vk.16 )
                                      case Proto1
                                      SOLVED // trace found
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed













/*
WARNING: the following wellformedness checks failed!

Message Derivation Checks
=========================

  The variables of the following rule(s) are not derivable from their premises, you may be performing unintended pattern matching.

Rule Reveal_sessk: 
Failed to derive Variable(s): sessKey

Rule Proto3: 
Failed to derive Variable(s): ~eb, ~ec, XB, XC
*/

/*
Generated from:
Tamarin version 1.11.0
Maude version 3.2.1
Git revision: d8e8266fc8aa702ff3c4d08608a7fbbe124eea65, branch: cyclic-squashed
Compiled at: 2024-11-27 09:37:37.786154 UTC
*/

end
/* Output

==============================================================================
summary of summaries:

analyzed: examples/ake/bilinear/TAK1_eCK_like.spthy

  output:          examples/ake/bilinear/TAK1_eCK_like.spthy.tmp
  processing time: 20.97s
  
  WARNING: 1 wellformedness check failed!
           The analysis results might be wrong!
  
  session_key_establish (exists-trace): verified (17 steps)
  Session_Key_Secrecy (all-traces): falsified - found trace (21 steps)

==============================================================================
*/
