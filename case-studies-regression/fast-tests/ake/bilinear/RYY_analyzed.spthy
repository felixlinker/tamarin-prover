theory RYY begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman, bilinear-pairing
functions: fst/1, hp/1, kdf/1, pair/2, snd/1
equations: fst(<x.1, x.2>) = x.1, snd(<x.1, x.2>) = x.2







section{* RYY : UM-like identity based key exchange protocol *}

rule (modulo E) KGC_Setup:
   [ Fr( msk ) ] --> [ !MSK( msk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) KGC_request:
   [ !MSK( s ) ] --> [ !LTK( $ID, pmult(s, hp($ID)) ) ]

  /*
  rule (modulo AC) KGC_request:
     [ !MSK( s ) ] --> [ !LTK( $ID, z ) ]
    variants (modulo AC)
    1. $ID   = $ID.2
       s     = one
       z     = hp($ID.2)
    
    2. $ID   = $ID.2
       s     = s.2
       z     = pmult(s.2, hp($ID.2))
  */

rule (modulo E) Reveal_ltk:
   [ !LTK( $ID, skID ) ] --[ LtkRev( $ID ) ]-> [ Out( skID ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_master_key:
   [ !MSK( msk ) ] --[ MskRev( ) ]-> [ Out( msk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_session_key:
   [ !Sessk( ~ey, sek ) ] --[ SesskRev( ~ey ) ]-> [ Out( sek ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Init_1:
   [ Fr( ~ex ) ] --> [ Init( ~ex, $A, $B ), Out( 'g'^~ex ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Init_2:
   [ Init( ~ex, $A, $B ), !LTK( $A, skA ), In( Y ) ]
  --[
  Accept( ~ex, kdf(<Y^~ex, em(skA, hp($B)), $A, $B, 'g'^~ex, Y>) ),
  Sid( ~ex, <$A, $B, 'g'^~ex, Y, 'Init'> )
  ]->
   [ !Sessk( ~ex, kdf(<Y^~ex, em(skA, hp($B)), $A, $B, 'g'^~ex, Y>) ) ]

  /*
  rule (modulo AC) Init_2:
     [ Init( ~ex, $A, $B ), !LTK( $A, skA ), In( Y ) ]
    --[
    Accept( ~ex, kdf(<z, z.1, $A, $B, 'g'^~ex, Y>) ),
    Sid( ~ex, <$A, $B, 'g'^~ex, Y, 'Init'> )
    ]->
     [ !Sessk( ~ex, kdf(<z, z.1, $A, $B, 'g'^~ex, Y>) ) ]
    variants (modulo AC)
     1. $B    = $B.3
        ~ex   = ~x.2
        Y     = x.3^inv(~x.2)
        skA   = skA.3
        z     = x.3
        z.1   = em(skA.3, hp($B.3))
    
     2. $B    = $B.3
        ~ex   = ~x.4
        Y     = x.5^inv(~x.4)
        skA   = pmult(x.6, x.7)
        z     = x.5
        z.1   = em(x.7, hp($B.3))^x.6
    
     3. $B    = $B.3
        Y     = DH_neutral
        skA   = skA.3
        z     = DH_neutral
        z.1   = em(skA.3, hp($B.3))
    
     4. $B    = $B.3
        Y     = DH_neutral
        skA   = pmult(x.2, x.3)
        z     = DH_neutral
        z.1   = em(x.3, hp($B.3))^x.2
    
     5. $B    = $B.3
        ~ex   = ~ex.3
        Y     = x.2^x.3
        skA   = skA.3
        z     = x.2^(~ex.3*x.3)
        z.1   = em(skA.3, hp($B.3))
    
     6. $B    = $B.3
        ~ex   = ~ex.3
        Y     = Y.3
        skA   = skA.3
        z     = Y.3^~ex.3
        z.1   = em(skA.3, hp($B.3))
    
     7. $B    = $B.3
        ~ex   = ~ex.3
        Y     = Y.3
        skA   = pmult(x.2, x.3)
        z     = Y.3^~ex.3
        z.1   = em(x.3, hp($B.3))^x.2
    
     8. $B    = $B.3
        ~ex   = ~x.3
        Y     = x.4^(x.5*inv(~x.3))
        skA   = skA.3
        z     = x.4^x.5
        z.1   = em(skA.3, hp($B.3))
    
     9. $B    = $B.3
        ~ex   = ~x.3
        Y     = x.4^inv((~x.3*x.5))
        skA   = skA.3
        z     = x.4^inv(x.5)
        z.1   = em(skA.3, hp($B.3))
    
    10. $B    = $B.3
        ~ex   = ~ex.3
        Y     = x.4^x.5
        skA   = pmult(x.6, x.7)
        z     = x.4^(~ex.3*x.5)
        z.1   = em(x.7, hp($B.3))^x.6
    
    11. $B    = $B.3
        ~ex   = ~x.4
        Y     = x.5^(x.6*inv((~x.4*x.7)))
        skA   = skA.3
        z     = x.5^(x.6*inv(x.7))
        z.1   = em(skA.3, hp($B.3))
    
    12. $B    = $B.3
        ~ex   = ~x.5
        Y     = x.6^(x.7*inv(~x.5))
        skA   = pmult(x.8, x.9)
        z     = x.6^x.7
        z.1   = em(x.9, hp($B.3))^x.8
    
    13. $B    = $B.3
        ~ex   = ~x.5
        Y     = x.6^inv((~x.5*x.7))
        skA   = pmult(x.8, x.9)
        z     = x.6^inv(x.7)
        z.1   = em(x.9, hp($B.3))^x.8
    
    14. $B    = $B.3
        ~ex   = ~x.6
        Y     = x.7^(x.8*inv((~x.6*x.9)))
        skA   = pmult(x.10, x.11)
        z     = x.7^(x.8*inv(x.9))
        z.1   = em(x.11, hp($B.3))^x.10
  */

rule (modulo E) Resp_1:
   [ Fr( ~ey ), !LTK( $B, skB ), In( X ) ]
  --[
  Accept( ~ey, kdf(<X^~ey, em(skB, hp($A)), $A, $B, X, 'g'^~ey>) ),
  Sid( ~ey, <$B, $A, 'g'^~ey, X, 'Resp'> )
  ]->
   [
   Out( 'g'^~ey ),
   !Sessk( ~ey, kdf(<X^~ey, em(skB, hp($A)), $A, $B, X, 'g'^~ey>) )
   ]

  /*
  rule (modulo AC) Resp_1:
     [ Fr( ~ey ), !LTK( $B, skB ), In( X ) ]
    --[
    Accept( ~ey, kdf(<z, z.1, $A, $B, X, 'g'^~ey>) ),
    Sid( ~ey, <$B, $A, 'g'^~ey, X, 'Resp'> )
    ]->
     [ Out( 'g'^~ey ), !Sessk( ~ey, kdf(<z, z.1, $A, $B, X, 'g'^~ey>) ) ]
    variants (modulo AC)
     1. $A    = $A.3
        ~ey   = ~x.2
        X     = x.3^inv(~x.2)
        skB   = skB.3
        z     = x.3
        z.1   = em(skB.3, hp($A.3))
    
     2. $A    = $A.3
        ~ey   = ~ey.3
        X     = X.3
        skB   = skB.3
        z     = X.3^~ey.3
        z.1   = em(skB.3, hp($A.3))
    
     3. $A    = $A.3
        ~ey   = ~ey.3
        X     = X.3
        skB   = pmult(x.2, x.3)
        z     = X.3^~ey.3
        z.1   = em(x.3, hp($A.3))^x.2
    
     4. $A    = $A.3
        ~ey   = ~ey.3
        X     = x.2^x.3
        skB   = skB.3
        z     = x.2^(~ey.3*x.3)
        z.1   = em(skB.3, hp($A.3))
    
     5. $A    = $A.3
        ~ey   = ~ey.3
        X     = x.4^x.5
        skB   = pmult(x.6, x.7)
        z     = x.4^(~ey.3*x.5)
        z.1   = em(x.7, hp($A.3))^x.6
    
     6. $A    = $A.3
        ~ey   = ~x.3
        X     = x.4^inv((~x.3*x.5))
        skB   = skB.3
        z     = x.4^inv(x.5)
        z.1   = em(skB.3, hp($A.3))
    
     7. $A    = $A.3
        ~ey   = ~x.3
        X     = x.4^(x.5*inv(~x.3))
        skB   = skB.3
        z     = x.4^x.5
        z.1   = em(skB.3, hp($A.3))
    
     8. $A    = $A.3
        ~ey   = ~x.4
        X     = x.5^inv(~x.4)
        skB   = pmult(x.6, x.7)
        z     = x.5
        z.1   = em(x.7, hp($A.3))^x.6
    
     9. $A    = $A.3
        ~ey   = ~x.4
        X     = x.5^(x.6*inv((~x.4*x.7)))
        skB   = skB.3
        z     = x.5^(x.6*inv(x.7))
        z.1   = em(skB.3, hp($A.3))
    
    10. $A    = $A.3
        ~ey   = ~x.5
        X     = x.6^inv((~x.5*x.7))
        skB   = pmult(x.8, x.9)
        z     = x.6^inv(x.7)
        z.1   = em(x.9, hp($A.3))^x.8
    
    11. $A    = $A.3
        ~ey   = ~x.5
        X     = x.6^(x.7*inv(~x.5))
        skB   = pmult(x.8, x.9)
        z     = x.6^x.7
        z.1   = em(x.9, hp($A.3))^x.8
    
    12. $A    = $A.3
        ~ey   = ~x.6
        X     = x.7^(x.8*inv((~x.6*x.9)))
        skB   = pmult(x.10, x.11)
        z     = x.7^(x.8*inv(x.9))
        z.1   = em(x.11, hp($A.3))^x.10
    
    13. $A    = $A.3
        X     = DH_neutral
        skB   = skB.3
        z     = DH_neutral
        z.1   = em(skB.3, hp($A.3))
    
    14. $A    = $A.3
        X     = DH_neutral
        skB   = pmult(x.2, x.3)
        z     = DH_neutral
        z.1   = em(x.3, hp($A.3))^x.2
  */

lemma key_agreement_reachable:
  exists-trace
  "∃ #i #j A B X Y t1 t2 k role1 role2.
    ((((Accept( t1, k ) @ #i) ∧ (Sid( t1, <A, B, X, Y, role1> ) @ #i)) ∧
      (Accept( t2, k ) @ #j)) ∧
     (Sid( t2, <B, A, Y, X, role2> ) @ #j)) ∧
    (¬(role1 = role2))"
/*
guarded formula characterizing all satisfying traces:
"∃ #i #j A B X Y t1 t2 k role1 role2.
  (Accept( t1, k ) @ #i) ∧
  (Sid( t1, <A, B, X, Y, role1> ) @ #i) ∧
  (Accept( t2, k ) @ #j) ∧
  (Sid( t2, <B, A, Y, X, role2> ) @ #j)
 ∧
  ¬(role1 = role2)"
*/
simplify
solve( Accept( t1, k ) @ #i )
  case Init_2
  solve( Init( ~ex, $A.1, $B.1 ) ▶₀ #i )
    case Init_1
    solve( !LTK( $A.1, skA ) ▶₁ #i )
      case KGC_request
      solve( Sid( ~ex, <A, B, X, Y, role1> ) @ #i )
        case Init_2
        solve( Accept( t2,
                       kdf(<z, em(hp($A.1), hp($B.1))^~n, $A.1, $B.1, 'g'^~ex, Y.1>)
               ) @ #j )
          case Resp_1
          solve( !LTK( $B.3, pmult(~n.1, hp($B.3)) ) ▶₁ #j )
            case KGC_request
            solve( Sid( ~ey.1, <$B.3, $A.2, 'g'^~ey.1, 'g'^~ex.1, role2> ) @ #j )
              case Resp_1
              solve( !KU( 'g'^~ey.1 ) @ #vk )
                case Resp_1
                solve( !KU( 'g'^~ex.1 ) @ #vk.2 )
                  case Init_1
                  SOLVED // trace found
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma key_secrecy_WPFS:
  all-traces
  "∀ #i1 #i2 test A B X Y role1 k.
    (((Accept( test, k ) @ #i1) ∧ (K( k ) @ #i2)) ∧
     (Sid( test, <A, B, X, Y, role1> ) @ #i1)) ⇒
    (((∃ #i3. SesskRev( test ) @ #i3) ∨
      (∃ matching #i3 role2.
        ((Sid( matching, <B, A, Y, X, role2> ) @ #i3) ∧ (¬(role1 = role2))) ∧
        ((((∃ #i5. SesskRev( matching ) @ #i5) ∨
           (∃ #i5. (LtkRev( B ) @ #i5) ∧ (#i5 < #i1))) ∨
          (∃ #i5. (LtkRev( A ) @ #i5) ∧ (#i5 < #i1))) ∨
         (∃ #i5. (MskRev( ) @ #i5) ∧ (#i5 < #i1))))) ∨
     ((¬(∃ matching #i3 role2.
          (Sid( matching, <B, A, Y, X, role2> ) @ #i3) ∧ (¬(role1 = role2)))) ∧
      (((∃ #i5. LtkRev( B ) @ #i5) ∨ (∃ #i3. LtkRev( A ) @ #i3)) ∨
       (∃ #i3. MskRev( ) @ #i3))))"
/*
guarded formula characterizing all counter-examples:
"∃ #i1 #i2 test A B X Y role1 k.
  (Accept( test, k ) @ #i1) ∧
  (K( k ) @ #i2) ∧
  (Sid( test, <A, B, X, Y, role1> ) @ #i1)
 ∧
  (∀ #i3. (SesskRev( test ) @ #i3) ⇒ ⊥) ∧
  (∀ matching #i3 role2.
    (Sid( matching, <B, A, Y, X, role2> ) @ #i3)
   ⇒
    ((role1 = role2) ∨
     ((∀ #i5. (SesskRev( matching ) @ #i5) ⇒ ⊥) ∧
      (∀ #i5. (LtkRev( B ) @ #i5) ⇒ ¬(#i5 < #i1)) ∧
      (∀ #i5. (LtkRev( A ) @ #i5) ⇒ ¬(#i5 < #i1)) ∧
      (∀ #i5. (MskRev( ) @ #i5) ⇒ ¬(#i5 < #i1))))) ∧
  (((∃ matching #i3 role2.
      (Sid( matching, <B, A, Y, X, role2> ) @ #i3) ∧ ¬(role1 = role2)) ∨
    ((∀ #i5. (LtkRev( B ) @ #i5) ⇒ ⊥) ∧
     (∀ #i3. (LtkRev( A ) @ #i3) ⇒ ⊥) ∧
     (∀ #i3. (MskRev( ) @ #i3) ⇒ ⊥))))"
*/
simplify
solve( (∃ matching #i3 role2.
         (Sid( matching, <B, A, Y, X, role2> ) @ #i3) ∧ ¬(role1 = role2))  ∥
       ((∀ #i5. (LtkRev( B ) @ #i5) ⇒ ⊥) ∧
        (∀ #i3. (LtkRev( A ) @ #i3) ⇒ ⊥) ∧
        (∀ #i3. (MskRev( ) @ #i3) ⇒ ⊥)) )
  case case_1
  solve( (role1 = role2)  ∥
         ((∀ #i5. (SesskRev( matching ) @ #i5) ⇒ ⊥) ∧
          (∀ #i5. (LtkRev( B ) @ #i5) ⇒ ¬(#i5 < #i1)) ∧
          (∀ #i5. (LtkRev( A ) @ #i5) ⇒ ¬(#i5 < #i1)) ∧
          (∀ #i5. (MskRev( ) @ #i5) ⇒ ¬(#i5 < #i1))) )
    case case_1
    by contradiction /* from formulas */
  next
    case case_2
    solve( Accept( test, x ) @ #i1 )
      case Init_2
      solve( Init( ~ex, $A.1, $B.1 ) ▶₀ #i1 )
        case Init_1
        solve( !LTK( $A.1, skA ) ▶₁ #i1 )
          case KGC_request
          solve( Sid( ~ex, <A, B, X, Y, role1> ) @ #i1 )
            case Init_2
            solve( Sid( matching, <$B.1, $A.1, Y.1, 'g'^~ex, role2> ) @ #i3 )
              case Init_2
              by contradiction /* from formulas */
            next
              case Resp_1
              solve( !LTK( $B.2, skB ) ▶₁ #i3 )
                case KGC_request
                solve( !KU( kdf(<'g'^(~ex.1*~ey.1), em(hp($A.3), hp($B.3))^~n, $A.3, 
                                 $B.3, 'g'^~ex.1, 'g'^~ey.1>)
                       ) @ #vk )
                  case Reveal_session_key_case_1
                  by contradiction /* from formulas */
                next
                  case Reveal_session_key_case_2
                  by contradiction /* from formulas */
                next
                  case c_kdf
                  solve( !KU( 'g'^(~ex.1*~ey.1) ) @ #vk.4 )
                    case Init_1
                    by solve( !KU( ~ey.2 ) @ #vk.14 )
                  next
                    case Resp_1
                    by solve( !KU( ~ex.2 ) @ #vk.15 )
                  next
                    case c_exp
                    by solve( !KU( ~ex.1 ) @ #vk.16 )
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    next
      case Resp_1
      solve( !LTK( $B.1, skB ) ▶₁ #i1 )
        case KGC_request
        solve( Sid( ~ey, <A, B, X, Y, role1> ) @ #i1 )
          case Resp_1
          solve( Sid( matching, <$A.1, $B.1, X.1, 'g'^~ey, role2> ) @ #i3 )
            case Init_2
            solve( Init( ~ex.1, $A.2, $B.2 ) ▶₀ #i3 )
              case Init_1
              solve( !LTK( $A.2, skA ) ▶₁ #i3 )
                case KGC_request
                solve( !KU( kdf(<'g'^(~ex.1*~ey.1), em(hp($A.3), hp($B.3))^~n, $A.3, 
                                 $B.3, 'g'^~ex.1, 'g'^~ey.1>)
                       ) @ #vk )
                  case Reveal_session_key_case_1
                  by contradiction /* from formulas */
                next
                  case Reveal_session_key_case_2
                  by contradiction /* from formulas */
                next
                  case c_kdf
                  solve( !KU( 'g'^(~ex.1*~ey.1) ) @ #vk.4 )
                    case Init_1
                    by solve( !KU( ~ey.2 ) @ #vk.14 )
                  next
                    case Resp_1
                    by solve( !KU( ~ex.2 ) @ #vk.15 )
                  next
                    case c_exp
                    by solve( !KU( ~ex.1 ) @ #vk.16 )
                  qed
                qed
              qed
            qed
          next
            case Resp_1
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  qed
next
  case case_2
  solve( Accept( test, x ) @ #i1 )
    case Init_2
    solve( Init( ~ex, $A.1, $B.1 ) ▶₀ #i1 )
      case Init_1
      solve( !LTK( $A.1, skA ) ▶₁ #i1 )
        case KGC_request
        solve( Sid( ~ex, <A, B, X, Y, role1> ) @ #i1 )
          case Init_2
          solve( !KU( kdf(<z, em(hp($A.1), hp($B.1))^~n, $A.1, $B.1, 'g'^~ex, Y.1>)
                 ) @ #vk )
            case Reveal_session_key_case_1
            by contradiction /* from formulas */
          next
            case Reveal_session_key_case_2
            by contradiction /* from formulas */
          next
            case c_kdf
            solve( !KU( em(hp($A.1), hp($B.1))^~n ) @ #vk.5 )
              case Reveal_ltk_case_1
              by contradiction /* from formulas */
            next
              case Reveal_ltk_case_2
              by contradiction /* from formulas */
            next
              case c_exp
              solve( !KU( ~n ) @ #vk.14 )
                case Reveal_master_key
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case Resp_1
    solve( !LTK( $B.1, skB ) ▶₁ #i1 )
      case KGC_request
      solve( Sid( ~ey, <A, B, X, Y, role1> ) @ #i1 )
        case Resp_1
        solve( !KU( kdf(<z, em(hp($A.1), hp($B.1))^~n, $A.1, $B.1, X.1, 'g'^~ey>)
               ) @ #vk )
          case Reveal_session_key_case_1
          by contradiction /* from formulas */
        next
          case Reveal_session_key_case_2
          by contradiction /* from formulas */
        next
          case c_kdf
          solve( !KU( em(hp($A.1), hp($B.1))^~n ) @ #vk.5 )
            case Reveal_ltk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_ltk_case_2
            by contradiction /* from formulas */
          next
            case c_exp
            solve( !KU( ~n ) @ #vk.14 )
              case Reveal_master_key
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  qed
qed











/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.11.0
Maude version 3.2.1
Git revision: d8e8266fc8aa702ff3c4d08608a7fbbe124eea65, branch: cyclic-squashed
Compiled at: 2024-11-27 09:37:37.786154 UTC
*/

end
/* Output

==============================================================================
summary of summaries:

analyzed: examples/ake/bilinear/RYY.spthy

  output:          examples/ake/bilinear/RYY.spthy.tmp
  processing time: 4.02s
  
  key_agreement_reachable (exists-trace): verified (11 steps)
  key_secrecy_WPFS (all-traces): verified (53 steps)

==============================================================================
*/
