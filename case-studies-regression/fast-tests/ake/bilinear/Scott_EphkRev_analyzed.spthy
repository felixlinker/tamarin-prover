theory Scott begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman, bilinear-pairing
functions: fst/1, hp/1, kdf/1, pair/2, snd/1
equations: fst(<x.1, x.2>) = x.1, snd(<x.1, x.2>) = x.2







section{* Scott: MTI-C0 like identity based key exchange protocol *}

rule (modulo E) KGC_Setup:
   [ Fr( ~msk ) ] --[ KGCSetup( ) ]-> [ !MSK( ~msk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) KGC_request:
   [ !MSK( ~msk ) ] --> [ !LTK( $ID, pmult(~msk, hp($ID)) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_ltk:
   [ !LTK( $ID, skID ) ] --[ LtkRev( $ID ) ]-> [ Out( skID ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_master_key:
   [ !MSK( ~msk ) ] --[ MskRev( ) ]-> [ Out( ~msk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_session_key:
   [ !Sessk( ~ey, sek ) ] --[ SesskRev( ~ey ) ]-> [ Out( sek ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_ephmeral_key:
   [ !Ephk( ~ey ) ] --[ EphkRev( ~ey ) ]-> [ Out( ~ey ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Init_1:
   [ Fr( ~ex ), !LTK( $A, pmult(~s, hp($A)) ) ]
  -->
   [
   Init( ~ex, $A, $B, em(hp($B), pmult(~s, hp($A)))^~ex ),
   Out( em(hp($B), pmult(~s, hp($A)))^~ex ), !Ephk( ~ex )
   ]

  /*
  rule (modulo AC) Init_1:
     [ Fr( ~ex ), !LTK( $A, pmult(~s, hp($A)) ) ]
    -->
     [
     Init( ~ex, $A, $B, em(hp($A), hp($B))^(~ex*~s) ),
     Out( em(hp($A), hp($B))^(~ex*~s) ), !Ephk( ~ex )
     ]
  */

rule (modulo E) Init_2:
   [ Init( ~ex, $A, $B, X ), In( Y ) ]
  --[
  Accept( ~ex, $A, $B, kdf(<Y^~ex, $A, $B, X, Y>) ),
  Sid( ~ex, <'Init', $A, $B, X, Y> ), Match( ~ex, <'Resp', $B, $A, X, Y> )
  ]->
   [ !Sessk( ~ex, kdf(<Y^~ex, $A, $B, X, Y>) ) ]

  /*
  rule (modulo AC) Init_2:
     [ Init( ~ex, $A, $B, X ), In( Y ) ]
    --[
    Accept( ~ex, $A, $B, kdf(<z, $A, $B, X, Y>) ),
    Sid( ~ex, <'Init', $A, $B, X, Y> ), Match( ~ex, <'Resp', $B, $A, X, Y> )
    ]->
     [ !Sessk( ~ex, kdf(<z, $A, $B, X, Y>) ) ]
    variants (modulo AC)
    1. ~ex   = ~x.3
       Y     = x.5^inv(~x.3)
       z     = x.5
    
    2. Y     = DH_neutral
       z     = DH_neutral
    
    3. ~ex   = ~ex.3
       Y     = x.2^x.3
       z     = x.2^(~ex.3*x.3)
    
    4. ~ex   = ~ex.3
       Y     = Y.3
       z     = Y.3^~ex.3
    
    5. ~ex   = ~x.4
       Y     = x.6^(x.7*inv(~x.4))
       z     = x.6^x.7
    
    6. ~ex   = ~x.4
       Y     = x.6^inv((~x.4*x.7))
       z     = x.6^inv(x.7)
    
    7. ~ex   = ~x.5
       Y     = x.7^(x.8*inv((~x.5*x.9)))
       z     = x.7^(x.8*inv(x.9))
  */

rule (modulo E) Resp_1:
   [ Fr( ~ey ), !LTK( $B, pmult(~s, hp($B)) ), In( X ) ]
  --[
  Accept( ~ey, $B, $A,
          kdf(<X^~ey, $A, $B, X, em(hp($A), pmult(~s, hp($B)))^~ey>)
  ),
  Sid( ~ey, <'Resp', $B, $A, X, em(hp($A), pmult(~s, hp($B)))^~ey> ),
  Match( ~ey, <'Init', $A, $B, X, em(hp($A), pmult(~s, hp($B)))^~ey> )
  ]->
   [
   Out( em(hp($A), pmult(~s, hp($B)))^~ey ),
   !Sessk( ~ey, kdf(<X^~ey, $A, $B, X, em(hp($A), pmult(~s, hp($B)))^~ey>)
   ),
   !Ephk( ~ey )
   ]

  /*
  rule (modulo AC) Resp_1:
     [ Fr( ~ey ), !LTK( $B, pmult(~x, hp($B)) ), In( X ) ]
    --[
    Accept( ~ey, $B, $A, kdf(<z, $A, $B, X, em(hp($A), hp($B))^(~ey*~x)>) ),
    Sid( ~ey, <'Resp', $B, $A, X, em(hp($A), hp($B))^(~ey*~x)> ),
    Match( ~ey, <'Init', $A, $B, X, em(hp($A), hp($B))^(~ey*~x)> )
    ]->
     [
     Out( em(hp($A), hp($B))^(~ey*~x) ),
     !Sessk( ~ey, kdf(<z, $A, $B, X, em(hp($A), hp($B))^(~ey*~x)>) ),
     !Ephk( ~ey )
     ]
    variants (modulo AC)
    1. ~ey   = ~ey.3
       X     = X.3
       z     = X.3^~ey.3
    
    2. ~ey   = ~ey.3
       X     = x.14^x.15
       z     = x.14^(~ey.3*x.15)
    
    3. ~ey   = ~x.15
       X     = x.17^inv(~x.15)
       z     = x.17
    
    4. ~ey   = ~x.16
       X     = x.18^inv((~x.16*x.19))
       z     = x.18^inv(x.19)
    
    5. ~ey   = ~x.16
       X     = x.18^(x.19*inv(~x.16))
       z     = x.18^x.19
    
    6. ~ey   = ~x.17
       X     = x.19^(x.20*inv((~x.17*x.21)))
       z     = x.19^(x.20*inv(x.21))
    
    7. X     = DH_neutral
       z     = DH_neutral
  */

lemma key_agreement_reachable:
  exists-trace
  "∃ #i #j A B SID t1 t2 k.
    (((Accept( t1, A, B, k ) @ #i) ∧ (Match( t1, SID ) @ #i)) ∧
     (Accept( t2, B, A, k ) @ #j)) ∧
    (Sid( t2, SID ) @ #j)"
/*
guarded formula characterizing all satisfying traces:
"∃ #i #j A B SID t1 t2 k.
  (Accept( t1, A, B, k ) @ #i) ∧
  (Match( t1, SID ) @ #i) ∧
  (Accept( t2, B, A, k ) @ #j) ∧
  (Sid( t2, SID ) @ #j)"
*/
simplify
solve( Accept( t1, A, B, k ) @ #i )
  case Init_2
  solve( Init( ~ex, $A.1, $B.1, X ) ▶₀ #i )
    case Init_1
    solve( Match( ~ex, SID ) @ #i )
      case Init_2
      solve( Accept( t2, $B.1, $A.1,
                     kdf(<z, $A.1, $B.1, em(hp($A.1), hp($B.1))^(~ex*~s), Y>)
             ) @ #j )
        case Resp_1
        solve( !LTK( $B.3, pmult(~x, hp($B.3)) ) ▶₁ #j )
          case KGC_request
          solve( Sid( ~ey.1,
                      <'Resp', $B.3, $A.3, em(hp($A.3), hp($B.3))^(~x*~ex.1), 
                       em(hp($A.3), hp($B.3))^(~x*~ey.1)>
                 ) @ #j )
            case Resp_1
            solve( !KU( em(hp($A.3), hp($B.3))^(~x*~ey.1) ) @ #vk )
              case Init_1_case_1
              solve( !KU( ~ey.2 ) @ #vk.6 )
                case Reveal_ephmeral_key
                solve( !KU( ~ex.2 ) @ #vk.8 )
                  case Reveal_ephmeral_key
                  solve( !KU( em(hp($A.6), hp($B.6))^(~ex.1*~s.2) ) @ #vk.9 )
                    case Init_1_case_1
                    SOLVED // trace found
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma key_secrecy:
  all-traces
  "∀ #i1 #i2 test A B k.
    ((Accept( test, A, B, k ) @ #i1) ∧ (K( k ) @ #i2)) ⇒
    (((((∃ #i3. SesskRev( test ) @ #i3) ∨
        (∃ #i3 #i4.
          ((KGCSetup( ) @ #i3) ∧ (KGCSetup( ) @ #i4)) ∧ (¬(#i3 = #i4)))) ∨
       (∃ #i5. (EphkRev( test ) @ #i5) ∧ (∃ #i6. LtkRev( A ) @ #i6))) ∨
      (∃ matching #i3 #i4 sid.
        ((Sid( matching, sid ) @ #i3) ∧ (Match( test, sid ) @ #i4)) ∧
        ((∃ #i5. SesskRev( matching ) @ #i5) ∨
         (∃ #i5. (EphkRev( matching ) @ #i5) ∧ (∃ #i6. LtkRev( B ) @ #i6))))) ∨
     ((¬(∃ matching #i3 #i4 sid.
          (Sid( matching, sid ) @ #i3) ∧ (Match( test, sid ) @ #i4))) ∧
      (((∃ #i5. LtkRev( B ) @ #i5) ∨ (∃ #i3. LtkRev( A ) @ #i3)) ∨
       (∃ #i3. MskRev( ) @ #i3))))"
/*
guarded formula characterizing all counter-examples:
"∃ #i1 #i2 test A B k.
  (Accept( test, A, B, k ) @ #i1) ∧ (K( k ) @ #i2)
 ∧
  (∀ #i3. (SesskRev( test ) @ #i3) ⇒ ⊥) ∧
  (∀ #i3 #i4. (KGCSetup( ) @ #i3) ∧ (KGCSetup( ) @ #i4) ⇒ #i3 = #i4) ∧
  (∀ #i5. (EphkRev( test ) @ #i5) ⇒ ∀ #i6. (LtkRev( A ) @ #i6) ⇒ ⊥) ∧
  (∀ matching #i3 #i4 sid.
    (Sid( matching, sid ) @ #i3) ∧ (Match( test, sid ) @ #i4)
   ⇒
    (∀ #i5. (SesskRev( matching ) @ #i5) ⇒ ⊥) ∧
    (∀ #i5. (EphkRev( matching ) @ #i5) ⇒ ∀ #i6. (LtkRev( B ) @ #i6) ⇒ ⊥)) ∧
  (((∃ matching #i3 #i4 sid.
      (Sid( matching, sid ) @ #i3) ∧ (Match( test, sid ) @ #i4)) ∨
    ((∀ #i5. (LtkRev( B ) @ #i5) ⇒ ⊥) ∧
     (∀ #i3. (LtkRev( A ) @ #i3) ⇒ ⊥) ∧
     (∀ #i3. (MskRev( ) @ #i3) ⇒ ⊥))))"
*/
simplify
solve( (∃ matching #i3 #i4 sid.
         (Sid( matching, sid ) @ #i3) ∧ (Match( test, sid ) @ #i4))  ∥
       ((∀ #i5. (LtkRev( B ) @ #i5) ⇒ ⊥) ∧
        (∀ #i3. (LtkRev( A ) @ #i3) ⇒ ⊥) ∧
        (∀ #i3. (MskRev( ) @ #i3) ⇒ ⊥)) )
  case case_2
  solve( Accept( test, A, B, x ) @ #i1 )
    case Init_2
    solve( Init( ~ex, $A.1, $B.1, X ) ▶₀ #i1 )
      case Init_1
      solve( !KU( kdf(<z, $A.1, $B.1, em(hp($A.1), hp($B.1))^(~ex*~s), Y>)
             ) @ #vk )
        case c_kdf
        solve( splitEqs(0) )
          case split_case_7
          solve( !KU( em(hp($A.1), hp($B.1))^(~ex*~s) ) @ #vk.9 )
            case Init_1_case_1
            SOLVED // trace found
          qed
        qed
      qed
    qed
  qed
qed











/*
WARNING: the following wellformedness checks failed!

Message Derivation Checks
=========================

  The variables of the following rule(s) are not derivable from their premises, you may be performing unintended pattern matching.

Rule Init_1: 
Failed to derive Variable(s): ~s

Rule Resp_1: 
Failed to derive Variable(s): ~s
*/

/*
Generated from:
Tamarin version 1.11.0
Maude version 3.2.1
Git revision: d8e8266fc8aa702ff3c4d08608a7fbbe124eea65, branch: cyclic-squashed
Compiled at: 2024-11-27 09:37:37.786154 UTC
*/

end
/* Output

==============================================================================
summary of summaries:

analyzed: examples/ake/bilinear/Scott_EphkRev.spthy

  output:          examples/ake/bilinear/Scott_EphkRev.spthy.tmp
  processing time: 5.89s
  
  WARNING: 1 wellformedness check failed!
           The analysis results might be wrong!
  
  key_agreement_reachable (exists-trace): verified (12 steps)
  key_secrecy (all-traces): falsified - found trace (8 steps)

==============================================================================
*/
