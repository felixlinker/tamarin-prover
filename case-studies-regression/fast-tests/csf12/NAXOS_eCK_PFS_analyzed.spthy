theory NAXOS_eCK_PFS begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman
functions: fst/1, h1/1, h2/1, pair/2, snd/1
equations: fst(<x.1, x.2>) = x.1, snd(<x.1, x.2>) = x.2







section{* NAXOS *}

rule (modulo E) generate_ltk:
   [ Fr( ~lkA ) ]
  --[ RegKey( $A ) ]->
   [ !Ltk( $A, ~lkA ), !Pk( $A, 'g'^~lkA ), Out( 'g'^~lkA ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Init_1:
   [ Fr( ~eskI ), !Ltk( $I, ~lkI ) ]
  -->
   [
   Init_1( ~eskI, $I, $R, ~lkI, 'g'^h1(<~eskI, ~lkI>) ),
   !Ephk( ~eskI, ~eskI ), Out( 'g'^h1(<~eskI, ~lkI>) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Init_2:
   [ Init_1( ~eskI, $I, $R, ~lkI, hkI ), !Pk( $R, 'g'^~lkR ), In( Y ) ]
  --[
  Accept( ~eskI, $I, $R,
          h2(<Y^~lkI, 'g'^~lkR^h1(<~eskI, ~lkI>), Y^h1(<~eskI, ~lkI>), $I, $R>)
  ),
  Sid( ~eskI, <'Init', $I, $R, hkI, Y> ),
  Match( ~eskI, <'Resp', $R, $I, hkI, Y> )
  ]->
   [
   !Sessk( ~eskI,
           h2(<Y^~lkI, 'g'^~lkR^h1(<~eskI, ~lkI>), Y^h1(<~eskI, ~lkI>), $I, $R>)
   )
   ]

  /*
  rule (modulo AC) Init_2:
     [ Init_1( ~eskI, $I, $R, ~lkI, hkI ), !Pk( $R, 'g'^~x ), In( Y ) ]
    --[
    Accept( ~eskI, $I, $R, h2(<z, 'g'^(~x*h1(<~eskI, ~lkI>)), z.1, $I, $R>)
    ),
    Sid( ~eskI, <'Init', $I, $R, hkI, Y> ),
    Match( ~eskI, <'Resp', $R, $I, hkI, Y> )
    ]->
     [ !Sessk( ~eskI, h2(<z, 'g'^(~x*h1(<~eskI, ~lkI>)), z.1, $I, $R>) ) ]
    variants (modulo AC)
     1. ~eskI = ~eskI.3
        ~lkI  = ~lkI.3
        Y     = Y.3
        z     = Y.3^~lkI.3
        z.1   = Y.3^h1(<~eskI.3, ~lkI.3>)
    
     2. ~eskI = ~eskI.3
        ~lkI  = ~lkI.3
        Y     = x.15^x.16
        z     = x.15^(~lkI.3*x.16)
        z.1   = x.15^(x.16*h1(<~eskI.3, ~lkI.3>))
    
     3. ~eskI = ~eskI.3
        ~lkI  = ~x.16
        Y     = x.18^inv(~x.16)
        z     = x.18
        z.1   = x.18^(h1(<~eskI.3, ~x.16>)*inv(~x.16))
    
     4. ~eskI = ~eskI.3
        ~lkI  = ~x.17
        Y     = x.19^inv((~x.17*x.20))
        z     = x.19^inv(x.20)
        z.1   = x.19^(h1(<~eskI.3, ~x.17>)*inv((~x.17*x.20)))
    
     5. ~eskI = ~eskI.3
        ~lkI  = ~x.17
        Y     = x.19^(x.20*inv(~x.17))
        z     = x.19^x.20
        z.1   = x.19^(x.20*h1(<~eskI.3, ~x.17>)*inv(~x.17))
    
     6. ~eskI = ~eskI.3
        ~lkI  = ~x.18
        Y     = x.20^(x.21*inv((~x.18*x.22)))
        z     = x.20^(x.21*inv(x.22))
        z.1   = x.20^(x.21*h1(<~eskI.3, ~x.18>)*inv((~x.18*x.22)))
    
     7. ~eskI = ~x.17
        ~lkI  = ~x.18
        Y     = x.20^inv(h1(<~x.17, ~x.18>))
        z     = x.20^(~x.18*inv(h1(<~x.17, ~x.18>)))
        z.1   = x.20
    
     8. ~eskI = ~x.17
        ~lkI  = ~x.18
        Y     = x.20^inv((~x.18*h1(<~x.17, ~x.18>)))
        z     = x.20^inv(h1(<~x.17, ~x.18>))
        z.1   = x.20^inv(~x.18)
    
     9. ~eskI = ~x.18
        ~lkI  = ~x.19
        Y     = x.21^inv((~x.19*x.22*h1(<~x.18, ~x.19>)))
        z     = x.21^inv((x.22*h1(<~x.18, ~x.19>)))
        z.1   = x.21^inv((~x.19*x.22))
    
    10. ~eskI = ~x.18
        ~lkI  = ~x.19
        Y     = x.21^inv((x.22*h1(<~x.18, ~x.19>)))
        z     = x.21^(~x.19*inv((x.22*h1(<~x.18, ~x.19>))))
        z.1   = x.21^inv(x.22)
    
    11. ~eskI = ~x.18
        ~lkI  = ~x.19
        Y     = x.21^(x.22*inv(h1(<~x.18, ~x.19>)))
        z     = x.21^(~x.19*x.22*inv(h1(<~x.18, ~x.19>)))
        z.1   = x.21^x.22
    
    12. ~eskI = ~x.18
        ~lkI  = ~x.19
        Y     = x.21^(x.22*inv((~x.19*h1(<~x.18, ~x.19>))))
        z     = x.21^(x.22*inv(h1(<~x.18, ~x.19>)))
        z.1   = x.21^(x.22*inv(~x.19))
    
    13. ~eskI = ~x.19
        ~lkI  = ~x.20
        Y     = x.22^(x.23*inv((~x.20*x.24*h1(<~x.19, ~x.20>))))
        z     = x.22^(x.23*inv((x.24*h1(<~x.19, ~x.20>))))
        z.1   = x.22^(x.23*inv((~x.20*x.24)))
    
    14. ~eskI = ~x.19
        ~lkI  = ~x.20
        Y     = x.22^(x.23*inv((x.24*h1(<~x.19, ~x.20>))))
        z     = x.22^(~x.20*x.23*inv((x.24*h1(<~x.19, ~x.20>))))
        z.1   = x.22^(x.23*inv(x.24))
    
    15. Y     = DH_neutral
        z     = DH_neutral
        z.1   = DH_neutral
  */

rule (modulo E) Resp_1:
   [ Fr( ~eskR ), !Ltk( $R, ~lkR ), !Pk( $I, 'g'^~lkI ), In( X ) ]
  --[
  Accept( ~eskR, $R, $I,
          h2(<'g'^~lkI^h1(<~eskR, ~lkR>), X^~lkR, X^h1(<~eskR, ~lkR>), $I, $R>)
  ),
  Sid( ~eskR, <'Resp', $R, $I, X, 'g'^h1(<~eskR, ~lkR>)> ),
  Match( ~eskR, <'Init', $I, $R, X, 'g'^h1(<~eskR, ~lkR>)> )
  ]->
   [
   Out( 'g'^h1(<~eskR, ~lkR>) ), !Ephk( ~eskR, ~eskR ),
   !Sessk( ~eskR,
           h2(<'g'^~lkI^h1(<~eskR, ~lkR>), X^~lkR, X^h1(<~eskR, ~lkR>), $I, $R>)
   )
   ]

  /*
  rule (modulo AC) Resp_1:
     [ Fr( ~eskR ), !Ltk( $R, ~lkR ), !Pk( $I, 'g'^~x ), In( X ) ]
    --[
    Accept( ~eskR, $R, $I, h2(<'g'^(~x*h1(<~eskR, ~lkR>)), z, z.1, $I, $R>)
    ),
    Sid( ~eskR, <'Resp', $R, $I, X, 'g'^h1(<~eskR, ~lkR>)> ),
    Match( ~eskR, <'Init', $I, $R, X, 'g'^h1(<~eskR, ~lkR>)> )
    ]->
     [
     Out( 'g'^h1(<~eskR, ~lkR>) ), !Ephk( ~eskR, ~eskR ),
     !Sessk( ~eskR, h2(<'g'^(~x*h1(<~eskR, ~lkR>)), z, z.1, $I, $R>) )
     ]
    variants (modulo AC)
     1. ~eskR = ~eskR.3
        ~lkR  = ~lkR.3
        X     = X.3
        z     = X.3^~lkR.3
        z.1   = X.3^h1(<~eskR.3, ~lkR.3>)
    
     2. ~eskR = ~eskR.3
        ~lkR  = ~lkR.3
        X     = x.22^x.23
        z     = x.22^(~lkR.3*x.23)
        z.1   = x.22^(x.23*h1(<~eskR.3, ~lkR.3>))
    
     3. ~eskR = ~eskR.3
        ~lkR  = ~x.22
        X     = x.23^inv(~x.22)
        z     = x.23
        z.1   = x.23^(h1(<~eskR.3, ~x.22>)*inv(~x.22))
    
     4. ~eskR = ~eskR.3
        ~lkR  = ~x.23
        X     = x.24^inv((~x.23*x.25))
        z     = x.24^inv(x.25)
        z.1   = x.24^(h1(<~eskR.3, ~x.23>)*inv((~x.23*x.25)))
    
     5. ~eskR = ~eskR.3
        ~lkR  = ~x.23
        X     = x.24^(x.25*inv(~x.23))
        z     = x.24^x.25
        z.1   = x.24^(x.25*h1(<~eskR.3, ~x.23>)*inv(~x.23))
    
     6. ~eskR = ~eskR.3
        ~lkR  = ~x.24
        X     = x.25^(x.26*inv((~x.24*x.27)))
        z     = x.25^(x.26*inv(x.27))
        z.1   = x.25^(x.26*h1(<~eskR.3, ~x.24>)*inv((~x.24*x.27)))
    
     7. ~eskR = ~x.24
        ~lkR  = ~x.26
        X     = x.27^inv(h1(<~x.24, ~x.26>))
        z     = x.27^(~x.26*inv(h1(<~x.24, ~x.26>)))
        z.1   = x.27
    
     8. ~eskR = ~x.24
        ~lkR  = ~x.26
        X     = x.27^inv((~x.26*h1(<~x.24, ~x.26>)))
        z     = x.27^inv(h1(<~x.24, ~x.26>))
        z.1   = x.27^inv(~x.26)
    
     9. ~eskR = ~x.25
        ~lkR  = ~x.27
        X     = x.28^inv((~x.27*x.29*h1(<~x.25, ~x.27>)))
        z     = x.28^inv((x.29*h1(<~x.25, ~x.27>)))
        z.1   = x.28^inv((~x.27*x.29))
    
    10. ~eskR = ~x.25
        ~lkR  = ~x.27
        X     = x.28^inv((x.29*h1(<~x.25, ~x.27>)))
        z     = x.28^(~x.27*inv((x.29*h1(<~x.25, ~x.27>))))
        z.1   = x.28^inv(x.29)
    
    11. ~eskR = ~x.25
        ~lkR  = ~x.27
        X     = x.28^(x.29*inv(h1(<~x.25, ~x.27>)))
        z     = x.28^(~x.27*x.29*inv(h1(<~x.25, ~x.27>)))
        z.1   = x.28^x.29
    
    12. ~eskR = ~x.25
        ~lkR  = ~x.27
        X     = x.28^(x.29*inv((~x.27*h1(<~x.25, ~x.27>))))
        z     = x.28^(x.29*inv(h1(<~x.25, ~x.27>)))
        z.1   = x.28^(x.29*inv(~x.27))
    
    13. ~eskR = ~x.26
        ~lkR  = ~x.28
        X     = x.29^(x.30*inv((~x.28*x.31*h1(<~x.26, ~x.28>))))
        z     = x.29^(x.30*inv((x.31*h1(<~x.26, ~x.28>))))
        z.1   = x.29^(x.30*inv((~x.28*x.31)))
    
    14. ~eskR = ~x.26
        ~lkR  = ~x.28
        X     = x.29^(x.30*inv((x.31*h1(<~x.26, ~x.28>))))
        z     = x.29^(~x.28*x.30*inv((x.31*h1(<~x.26, ~x.28>))))
        z.1   = x.29^(x.30*inv(x.31))
    
    15. X     = DH_neutral
        z     = DH_neutral
        z.1   = DH_neutral
  */

rule (modulo E) Sessk_reveal:
   [ !Sessk( ~tid, k ) ] --[ SesskRev( ~tid ) ]-> [ Out( k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Ltk_reveal:
   [ !Ltk( $A, lkA ) ] --[ LtkRev( $A ) ]-> [ Out( lkA ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Ephk_reveal:
   [ !Ephk( ~s, ~ek ) ] --[ EphkRev( ~s ) ]-> [ Out( ~ek ) ]

  /* has exactly the trivial AC variant */

lemma eCK_PFS_key_secrecy:
  all-traces
  "∀ #i1 #i2 Test A B k.
    ((Accept( Test, A, B, k ) @ #i1) ∧ (K( k ) @ #i2)) ⇒
    ((((∃ #i3. SesskRev( Test ) @ #i3) ∨
       (∃ MatchingSession #i3 #i4 ms.
         ((Sid( MatchingSession, ms ) @ #i3) ∧ (Match( Test, ms ) @ #i4)) ∧
         (∃ #i5. SesskRev( MatchingSession ) @ #i5))) ∨
      (∃ MatchingSession #i3 #i4 ms.
        ((Sid( MatchingSession, ms ) @ #i3) ∧ (Match( Test, ms ) @ #i4)) ∧
        ((∃ #i5 #i6. (LtkRev( A ) @ #i5) ∧ (EphkRev( Test ) @ #i6)) ∨
         (∃ #i5 #i6.
           (LtkRev( B ) @ #i5) ∧ (EphkRev( MatchingSession ) @ #i6))))) ∨
     ((¬(∃ MatchingSession #i3 #i4 ms.
          (Sid( MatchingSession, ms ) @ #i3) ∧ (Match( Test, ms ) @ #i4))) ∧
      ((∃ #i5. (LtkRev( B ) @ #i5) ∧ (#i5 < #i1)) ∨
       (∃ #i5 #i6. (LtkRev( A ) @ #i5) ∧ (EphkRev( Test ) @ #i6)))))"
/*
guarded formula characterizing all counter-examples:
"∃ #i1 #i2 Test A B k.
  (Accept( Test, A, B, k ) @ #i1) ∧ (K( k ) @ #i2)
 ∧
  (∀ #i3. (SesskRev( Test ) @ #i3) ⇒ ⊥) ∧
  (∀ MatchingSession #i3 #i4 ms.
    (Sid( MatchingSession, ms ) @ #i3) ∧ (Match( Test, ms ) @ #i4)
   ⇒
    ∀ #i5. (SesskRev( MatchingSession ) @ #i5) ⇒ ⊥) ∧
  (∀ MatchingSession #i3 #i4 ms.
    (Sid( MatchingSession, ms ) @ #i3) ∧ (Match( Test, ms ) @ #i4)
   ⇒
    (∀ #i5 #i6. (LtkRev( A ) @ #i5) ∧ (EphkRev( Test ) @ #i6) ⇒ ⊥) ∧
    (∀ #i5 #i6.
      (LtkRev( B ) @ #i5) ∧ (EphkRev( MatchingSession ) @ #i6) ⇒ ⊥)) ∧
  (((∃ MatchingSession #i3 #i4 ms.
      (Sid( MatchingSession, ms ) @ #i3) ∧ (Match( Test, ms ) @ #i4)) ∨
    ((∀ #i5. (LtkRev( B ) @ #i5) ⇒ ¬(#i5 < #i1)) ∧
     (∀ #i5 #i6. (LtkRev( A ) @ #i5) ∧ (EphkRev( Test ) @ #i6) ⇒ ⊥))))"
*/
simplify
solve( (∃ MatchingSession #i3 #i4 ms.
         (Sid( MatchingSession, ms ) @ #i3) ∧ (Match( Test, ms ) @ #i4))  ∥
       ((∀ #i5. (LtkRev( B ) @ #i5) ⇒ ¬(#i5 < #i1)) ∧
        (∀ #i5 #i6. (LtkRev( A ) @ #i5) ∧ (EphkRev( Test ) @ #i6) ⇒ ⊥)) )
  case case_2
  solve( Accept( Test, A, B, x ) @ #i1 )
    case Init_2
    solve( Init_1( ~eskI, $I, $R, ~lkI, hkI ) ▶₀ #i1 )
      case Init_1
      solve( !Pk( $R, 'g'^~x.1 ) ▶₁ #i1 )
        case generate_ltk
        solve( !KU( h2(<z, 'g'^(~x.1*h1(<~eskI, ~lkI>)), z.1, $I, $R>) ) @ #vk )
          case c_h2
          solve( !KU( 'g'^(~x.1*h1(<~eskI, ~lkI>)) ) @ #vk.5 )
            case Init_1
            solve( !KU( ~x.2 ) @ #vk.11 )
              case Ltk_reveal
              solve( splitEqs(0) )
                case split_case_01
                solve( !KU( Y.1^~lkI.2 ) @ #vk.3 )
                  case c_exp
                  solve( !KU( ~lkI.2 ) @ #vk.13 )
                    case Ltk_reveal
                    solve( !KU( Y.1^h1(<~eskI.2, ~lkI.2>) ) @ #vk.7 )
                      case Init_1
                      SOLVED // trace found
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed











/*
WARNING: the following wellformedness checks failed!

Message Derivation Checks
=========================

  The variables of the following rule(s) are not derivable from their premises, you may be performing unintended pattern matching.

Rule Init_2: 
Failed to derive Variable(s): ~lkR

Rule Resp_1: 
Failed to derive Variable(s): ~lkI
*/

/*
Generated from:
Tamarin version 1.11.0
Maude version 3.2.1
Git revision: d8e8266fc8aa702ff3c4d08608a7fbbe124eea65, branch: cyclic-squashed
Compiled at: 2024-11-27 09:37:37.786154 UTC
*/

end
/* Output

==============================================================================
summary of summaries:

analyzed: examples/csf12/NAXOS_eCK_PFS.spthy

  output:          examples/csf12/NAXOS_eCK_PFS.spthy.tmp
  processing time: 1.25s
  
  WARNING: 1 wellformedness check failed!
           The analysis results might be wrong!
  
  eCK_PFS_key_secrecy (all-traces): falsified - found trace (13 steps)

==============================================================================
*/
