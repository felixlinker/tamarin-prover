theory StatVerif_GM_Contract_Signing begin

// Function signature and definition of the equational theory E

functions: check_getmsg/2, checkpcs/5, convertpcs/2, fst/1, pair/2,
           pcs/3, pk/1, sign/2, snd/1, true/0
equations:
    check_getmsg(pk(xsk), sign(xsk, xm)) = xm,
    checkpcs(xc, pk(xsk), ypk, zpk, pcs(sign(xsk, xc), ypk, zpk)) = true,
    convertpcs(zsk, pcs(sign(xsk, xc), ypk, pk(zsk))) = sign(xsk, xc),
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2





rule (modulo E) Setup_TTP:
   [ Fr( seed ) ] --> [ !TTP( seed ), Out( pk(seed) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Abort1:
   [ !TTP( skT ), In( <'abort', ct, pk1, pk2, pcsig1> ) ]
  --[
  Answered( ct ), Eq( checkpcs(ct, pk1, pk2, pk(skT), pcsig1), true ),
  Abort1( ct )
  ]->
   [ Out( sign(skT, pcsig1) ) ]

  /*
  rule (modulo AC) Abort1:
     [ !TTP( skT ), In( <'abort', ct, pk1, pk2, pcsig1> ) ]
    --[ Answered( ct ), Eq( z, true ), Abort1( ct ) ]->
     [ Out( sign(skT, pcsig1) ) ]
    variants (modulo AC)
    1. ct    = ct.3
       pcsig1
             = pcsig1.3
       pk1   = pk1.3
       pk2   = pk2.3
       skT   = skT.3
       z     = checkpcs(ct.3, pk1.3, pk2.3, pk(skT.3), pcsig1.3)
    
    2. ct    = x.4
       pcsig1
             = pcs(sign(x.5, x.4), x.6, pk(x.7))
       pk1   = pk(x.5)
       pk2   = x.6
       skT   = x.7
       z     = true
  */

rule (modulo E) Resolve2:
   [ !TTP( skT ), In( <'resolve2', ct, pk1, pk2, pcsig1, sig2> ) ]
  --[
  Answered( ct ), Eq( check_getmsg(pk2, sig2), ct ),
  Eq( checkpcs(ct, pk1, pk2, pk(skT), pcsig1), true ), Resolve2( ct )
  ]->
   [ Out( sign(skT, <convertpcs(skT, pcsig1), sig2>) ) ]

  /*
  rule (modulo AC) Resolve2:
     [ !TTP( skT ), In( <'resolve2', ct, pk1, pk2, pcsig1, sig2> ) ]
    --[ Answered( ct ), Eq( z.1, ct ), Eq( z.2, true ), Resolve2( ct ) ]->
     [ Out( sign(skT, <z, sig2>) ) ]
    variants (modulo AC)
    1. ct    = ct.3
       pcsig1
             = pcsig1.3
       pk1   = pk1.3
       pk2   = pk2.3
       sig2  = sig2.3
       skT   = skT.3
       z     = convertpcs(skT.3, pcsig1.3)
       z.1   = check_getmsg(pk2.3, sig2.3)
       z.2   = checkpcs(ct.3, pk1.3, pk2.3, pk(skT.3), pcsig1.3)
    
    2. ct    = ct.3
       pcsig1
             = pcsig1.3
       pk1   = pk1.3
       pk2   = pk(x.2)
       sig2  = sign(x.2, x.3)
       skT   = skT.3
       z     = convertpcs(skT.3, pcsig1.3)
       z.1   = x.3
       z.2   = checkpcs(ct.3, pk1.3, pk(x.2), pk(skT.3), pcsig1.3)
    
    3. ct    = ct.3
       pcsig1
             = pcs(sign(x.4, x.5), x.6, pk(x.7))
       pk1   = pk1.3
       pk2   = pk2.3
       sig2  = sig2.3
       skT   = x.7
       z     = sign(x.4, x.5)
       z.1   = check_getmsg(pk2.3, sig2.3)
       z.2   = checkpcs(ct.3, pk1.3, pk2.3, pk(x.7),
                        pcs(sign(x.4, x.5), x.6, pk(x.7)))
    
    4. ct    = ct.3
       pcsig1
             = pcs(sign(x.7, x.8), x.9, pk(x.10))
       pk1   = pk1.3
       pk2   = pk(x.12)
       sig2  = sign(x.12, x.13)
       skT   = x.10
       z     = sign(x.7, x.8)
       z.1   = x.13
       z.2   = checkpcs(ct.3, pk1.3, pk(x.12), pk(x.10),
                        pcs(sign(x.7, x.8), x.9, pk(x.10)))
    
    5. ct    = x.4
       pcsig1
             = pcs(sign(x.5, x.4), x.6, pk(x.7))
       pk1   = pk(x.5)
       pk2   = x.6
       sig2  = sig2.3
       skT   = x.7
       z     = sign(x.5, x.4)
       z.1   = check_getmsg(x.6, sig2.3)
       z.2   = true
    
    6. ct    = x.5
       pcsig1
             = pcs(sign(x.6, x.5), pk(x.7), pk(x.8))
       pk1   = pk(x.6)
       pk2   = pk(x.7)
       sig2  = sign(x.7, x.9)
       skT   = x.8
       z     = sign(x.6, x.5)
       z.1   = x.9
       z.2   = true
  */

rule (modulo E) Resolve1:
   [ !TTP( skT ), In( <'resolve1', ct, pk1, pk2, sig1, pcsig2> ) ]
  --[
  Answered( ct ), Eq( check_getmsg(pk1, sig1), ct ),
  Eq( checkpcs(ct, pk2, pk1, pk(skT), pcsig2), true ), Resolve1( ct )
  ]->
   [ Out( sign(skT, <sig1, convertpcs(skT, pcsig2)>) ) ]

  /*
  rule (modulo AC) Resolve1:
     [ !TTP( skT ), In( <'resolve1', ct, pk1, pk2, sig1, pcsig2> ) ]
    --[ Answered( ct ), Eq( z.1, ct ), Eq( z.2, true ), Resolve1( ct ) ]->
     [ Out( sign(skT, <sig1, z>) ) ]
    variants (modulo AC)
    1. ct    = ct.3
       pcsig2
             = pcsig2.3
       pk1   = pk1.3
       pk2   = pk2.3
       sig1  = sig1.3
       skT   = skT.3
       z     = convertpcs(skT.3, pcsig2.3)
       z.1   = check_getmsg(pk1.3, sig1.3)
       z.2   = checkpcs(ct.3, pk2.3, pk1.3, pk(skT.3), pcsig2.3)
    
    2. ct    = ct.3
       pcsig2
             = pcsig2.3
       pk1   = pk(x.3)
       pk2   = pk2.3
       sig1  = sign(x.3, x.5)
       skT   = skT.3
       z     = convertpcs(skT.3, pcsig2.3)
       z.1   = x.5
       z.2   = checkpcs(ct.3, pk2.3, pk(x.3), pk(skT.3), pcsig2.3)
    
    3. ct    = ct.3
       pcsig2
             = pcs(sign(x.4, x.5), x.6, pk(x.7))
       pk1   = pk1.3
       pk2   = pk2.3
       sig1  = sig1.3
       skT   = x.7
       z     = sign(x.4, x.5)
       z.1   = check_getmsg(pk1.3, sig1.3)
       z.2   = checkpcs(ct.3, pk2.3, pk1.3, pk(x.7),
                        pcs(sign(x.4, x.5), x.6, pk(x.7)))
    
    4. ct    = ct.3
       pcsig2
             = pcs(sign(x.7, x.8), x.9, pk(x.10))
       pk1   = pk(x.11)
       pk2   = pk2.3
       sig1  = sign(x.11, x.13)
       skT   = x.10
       z     = sign(x.7, x.8)
       z.1   = x.13
       z.2   = checkpcs(ct.3, pk2.3, pk(x.11), pk(x.10),
                        pcs(sign(x.7, x.8), x.9, pk(x.10)))
    
    5. ct    = x.4
       pcsig2
             = pcs(sign(x.5, x.4), x.6, pk(x.7))
       pk1   = x.6
       pk2   = pk(x.5)
       sig1  = sig1.3
       skT   = x.7
       z     = sign(x.5, x.4)
       z.1   = check_getmsg(x.6, sig1.3)
       z.2   = true
    
    6. ct    = x.5
       pcsig2
             = pcs(sign(x.6, x.5), pk(x.7), pk(x.8))
       pk1   = pk(x.7)
       pk2   = pk(x.6)
       sig1  = sign(x.7, x.9)
       skT   = x.8
       z     = sign(x.6, x.5)
       z.1   = x.9
       z.2   = true
  */

rule (modulo E) Witness_Aborted:
   [ In( sign(skT, pcs(sign(sk1, ct), pk(ysk), pk(skT))) ), !TTP( skT ) ]
  --[ AbortCert( ct ) ]->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Witness_Resolved:
   [ In( sign(skT, <sign(sk1, ct), sign(sk2, ct)>) ), !TTP( skT ) ]
  --[ ResolveCert( ct ) ]->
   [ ]

  /* has exactly the trivial AC variant */

restriction Answered_unique:
  "∀ x #i #j. ((Answered( x ) @ #i) ∧ (Answered( x ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction Eq_checks_succeed:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

lemma aborted_and_resolved_exclusive:
  all-traces
  "¬(∃ ct #i #j. (AbortCert( ct ) @ #i) ∧ (ResolveCert( ct ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ct #i #j. (AbortCert( ct ) @ #i) ∧ (ResolveCert( ct ) @ #j)"
*/
simplify
solve( !TTP( skT ) ▶₁ #i )
  case Setup_TTP
  solve( !TTP( skT.1 ) ▶₁ #j )
    case Setup_TTP
    solve( !KU( sign(~n, pcs(sign(sk1, ct.2), pk(ysk), pk(~n))) ) @ #vk )
      case Abort1
      solve( !KU( sign(~n.1, <sign(sk1.1, ct.2), sign(sk2, ct.2)>) ) @ #vk.1 )
        case c_sign
        by solve( !KU( ~n.1 ) @ #vk.13 )
      qed
    next
      case c_sign
      by solve( !KU( ~n ) @ #vk.2 )
    qed
  qed
qed

lemma aborted_contract_reachable:
  exists-trace
  "(((∃ ct #i. AbortCert( ct ) @ #i) ∧
     (∀ ct1 ct2 #i1 #i2.
       ((Abort1( ct1 ) @ #i1) ∧ (Abort1( ct2 ) @ #i2)) ⇒ (#i1 = #i2))) ∧
    (∀ ct #i. (Resolve1( ct ) @ #i) ⇒ (⊥))) ∧
   (∀ ct #i. (Resolve2( ct ) @ #i) ⇒ (⊥))"
/*
guarded formula characterizing all satisfying traces:
"(∃ ct #i. (AbortCert( ct ) @ #i)) ∧
 (∀ ct1 ct2 #i1 #i2.
   (Abort1( ct1 ) @ #i1) ∧ (Abort1( ct2 ) @ #i2) ⇒ #i1 = #i2) ∧
 (∀ ct #i. (Resolve1( ct ) @ #i) ⇒ ⊥) ∧
 (∀ ct #i. (Resolve2( ct ) @ #i) ⇒ ⊥)"
*/
simplify
solve( !TTP( skT ) ▶₁ #i )
  case Setup_TTP
  solve( !KU( sign(~n, pcs(sign(sk1, ct.1), pk(ysk), pk(~n))) ) @ #vk )
    case Abort1
    solve( !KU( sign(sk1, ct.1) ) @ #vk.9 )
      case c_sign
      solve( !KU( pk(sk1) ) @ #vk.7 )
        case c_pk
        solve( !KU( pk(ysk) ) @ #vk.10 )
          case Setup_TTP
          solve( !KU( pk(~n) ) @ #vk.11 )
            case Setup_TTP
            SOLVED // trace found
          qed
        qed
      qed
    qed
  qed
qed

lemma resolved1_contract_reachable:
  exists-trace
  "(((∃ ct #i. ResolveCert( ct ) @ #i) ∧
     (∀ ct #i. (Abort1( ct ) @ #i) ⇒ (⊥))) ∧
    (∀ ct1 ct2 #i1 #i2.
      ((Resolve1( ct1 ) @ #i1) ∧ (Resolve1( ct2 ) @ #i2)) ⇒ (#i1 = #i2))) ∧
   (∀ ct #i. (Resolve2( ct ) @ #i) ⇒ (⊥))"
/*
guarded formula characterizing all satisfying traces:
"(∃ ct #i. (ResolveCert( ct ) @ #i)) ∧
 (∀ ct #i. (Abort1( ct ) @ #i) ⇒ ⊥) ∧
 (∀ ct1 ct2 #i1 #i2.
   (Resolve1( ct1 ) @ #i1) ∧ (Resolve1( ct2 ) @ #i2) ⇒ #i1 = #i2) ∧
 (∀ ct #i. (Resolve2( ct ) @ #i) ⇒ ⊥)"
*/
simplify
solve( !TTP( skT ) ▶₁ #i )
  case Setup_TTP
  solve( !KU( sign(~n, <sign(sk1, ct.1), sign(sk2, ct.1)>) ) @ #vk )
    case Resolve1
    solve( !KU( sign(sk1.1, ct.1) ) @ #vk.10 )
      case c_sign
      solve( !KU( sign(sk2, ct.1) ) @ #vk.11 )
        case c_sign
        solve( !KU( pk(sk2) ) @ #vk.8 )
          case c_pk
          solve( !KU( pk(sk1.1) ) @ #vk.12 )
            case c_pk
            solve( !KU( pk(~n) ) @ #vk.13 )
              case Setup_TTP
              SOLVED // trace found
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma resolved2_contract_reachable:
  exists-trace
  "(((∃ ct #i. ResolveCert( ct ) @ #i) ∧
     (∀ ct #i. (Abort1( ct ) @ #i) ⇒ (⊥))) ∧
    (∀ ct #i. (Resolve1( ct ) @ #i) ⇒ (⊥))) ∧
   (∀ ct1 ct2 #i1 #i2.
     ((Resolve2( ct1 ) @ #i1) ∧ (Resolve2( ct2 ) @ #i2)) ⇒ (#i1 = #i2))"
/*
guarded formula characterizing all satisfying traces:
"(∃ ct #i. (ResolveCert( ct ) @ #i)) ∧
 (∀ ct #i. (Abort1( ct ) @ #i) ⇒ ⊥) ∧
 (∀ ct #i. (Resolve1( ct ) @ #i) ⇒ ⊥) ∧
 (∀ ct1 ct2 #i1 #i2.
   (Resolve2( ct1 ) @ #i1) ∧ (Resolve2( ct2 ) @ #i2) ⇒ #i1 = #i2)"
*/
simplify
solve( !TTP( skT ) ▶₁ #i )
  case Setup_TTP
  solve( !KU( sign(~n, <sign(sk1, ct.1), sign(sk2, ct.1)>) ) @ #vk )
    case Resolve2
    solve( !KU( sign(sk2.1, ct.1) ) @ #vk.10 )
      case c_sign
      solve( !KU( sign(sk1, ct.1) ) @ #vk.11 )
        case c_sign
        solve( !KU( pk(sk1) ) @ #vk.7 )
          case c_pk
          solve( !KU( pk(sk2.1) ) @ #vk.12 )
            case c_pk
            solve( !KU( pk(~n) ) @ #vk.13 )
              case Setup_TTP
              SOLVED // trace found
            qed
          qed
        qed
      qed
    qed
  qed
qed





















/*
WARNING: the following wellformedness checks failed!

Message Derivation Checks
=========================

  The variables of the following rule(s) are not derivable from their premises, you may be performing unintended pattern matching.

Rule Witness_Aborted: 
Failed to derive Variable(s): ct, sk1, ysk

Rule Witness_Resolved: 
Failed to derive Variable(s): ct, sk1, sk2
*/

/*
Generated from:
Tamarin version 1.11.0
Maude version 3.2.1
Git revision: d8e8266fc8aa702ff3c4d08608a7fbbe124eea65, branch: cyclic-squashed
Compiled at: 2024-11-27 09:37:37.786154 UTC
*/

end
/* Output

==============================================================================
summary of summaries:

analyzed: examples/related_work/StatVerif_ARR_CSF11/StatVerif_GM_Contract_Signing.spthy

  output:          examples/related_work/StatVerif_ARR_CSF11/StatVerif_GM_Contract_Signing.spthy.tmp
  processing time: 0.45s
  
  WARNING: 1 wellformedness check failed!
           The analysis results might be wrong!
  
  aborted_and_resolved_exclusive (all-traces): verified (7 steps)
  aborted_contract_reachable (exists-trace): verified (8 steps)
  resolved1_contract_reachable (exists-trace): verified (9 steps)
  resolved2_contract_reachable (exists-trace): verified (9 steps)

==============================================================================
*/
