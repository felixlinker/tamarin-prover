theory CRXOR begin

// Function signature and definition of the equational theory E

builtins: xor
functions: fst/1, h/1, pair/2, snd/1
equations: fst(<x.1, x.2>) = x.1, snd(<x.1, x.2>) = x.2









rule (modulo E) Setup:
   [ Fr( ~k ) ] --[ OnlyOnce( ) ]-> [ !InitLTK( ~k ), !RespLTK( ~k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) initiator:
   [ Fr( ~na ) ] --[ Challenge( ~na ) ]-> [ Out( ~na ), Initiated( ~na ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) responder:
   [ In( na ), Fr( ~nb ), !RespLTK( ~k ) ]
  --[ Response( ~k ), Neq( na, zero ), NeqForExec( na, zero ) ]->
   [ Out( <h((~k⊕~nb⊕na)), ~nb> ) ]

  /*
  rule (modulo AC) responder:
     [ In( na ), Fr( ~nb ), !RespLTK( ~k ) ]
    --[ Response( ~k ), Neq( na, zero ), NeqForExec( na, zero ) ]->
     [ Out( <h(z), ~nb> ) ]
    variants (modulo AC)
    1. ~k    = ~k.2
       ~nb   = ~x
       na    = ~x
       z     = ~k.2
    
    2. ~k    = ~x
       ~nb   = ~nb.2
       na    = ~x
       z     = ~nb.2
    
    3. ~k    = ~x
       ~nb   = ~x
       na    = na.2
       z     = na.2
    
    4. ~k    = ~x
       ~nb   = ~x.1
       na    = (~x⊕~x.1⊕x.2)
       z     = x.2
    
    5. ~k    = ~x
       ~nb   = ~x.1
       na    = (~x⊕~x.1)
       z     = zero
    
    6. ~k    = ~k.2
       ~nb   = ~x
       na    = (~x⊕x.1)
       z     = (x.1⊕~k.2)
    
    7. ~k    = ~k.2
       ~nb   = ~nb.2
       na    = zero
       z     = (~k.2⊕~nb.2)
    
    8. ~k    = ~k.2
       ~nb   = ~nb.2
       na    = na.2
       z     = (~k.2⊕~nb.2⊕na.2)
    
    9. ~k    = ~x
       ~nb   = ~nb.2
       na    = (~x⊕x.2)
       z     = (~nb.2⊕x.2)
  */

rule (modulo E) initiator2:
   [ Initiated( ~na ), !InitLTK( ~k ), In( <m, nb> ) ]
  --[ Alive( ~na, ~k ), Eq( h((~k⊕~na⊕nb)), m ) ]->
   [ ]

  /*
  rule (modulo AC) initiator2:
     [ Initiated( ~na ), !InitLTK( ~k ), In( <m, nb> ) ]
    --[ Alive( ~na, ~k ), Eq( h(z), m ) ]->
     [ ]
    variants (modulo AC)
    1. ~k    = ~k.2
       ~na   = ~x
       nb    = ~x
       z     = ~k.2
    
    2. ~k    = ~x
       ~na   = ~na.2
       nb    = ~x
       z     = ~na.2
    
    3. ~k    = ~x
       ~na   = ~x
       nb    = nb.2
       z     = nb.2
    
    4. ~k    = ~x
       ~na   = ~x.1
       nb    = (~x⊕~x.1⊕x.3)
       z     = x.3
    
    5. ~k    = ~x
       ~na   = ~x.1
       nb    = (~x⊕~x.1)
       z     = zero
    
    6. ~k    = ~k.2
       ~na   = ~na.2
       nb    = zero
       z     = (~k.2⊕~na.2)
    
    7. ~k    = ~k.2
       ~na   = ~na.2
       nb    = nb.2
       z     = (~k.2⊕~na.2⊕nb.2)
    
    8. ~k    = ~k.2
       ~na   = ~x
       nb    = (~x⊕x.2)
       z     = (~k.2⊕x.2)
    
    9. ~k    = ~x
       ~na   = ~na.2
       nb    = (~x⊕x.3)
       z     = (~na.2⊕x.3)
  */

restriction equality:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

restriction unique:
  "∀ #i #j. ((OnlyOnce( ) @ #i) ∧ (OnlyOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction inequality:
  "¬(∃ x #i. Neq( x, x ) @ #i)"
  // safety formula

lemma alive:
  all-traces "∀ x y #i. (Alive( x, y ) @ #i) ⇒ (∃ #j. Response( y ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ x y #i. (Alive( x, y ) @ #i) ∧ ∀ #j. (Response( y ) @ #j) ⇒ ⊥"
*/
simplify
solve( Initiated( ~na ) ▶₀ #i )
  case initiator
  solve( !InitLTK( ~k ) ▶₁ #i )
    case Setup
    solve( splitEqs(0) )
      case split_case_1
      by solve( !KU( ~k.1 ) @ #vk.2 )
    next
      case split_case_2
      solve( !KU( h(~k.1) ) @ #vk.1 )
        case c_h
        by solve( !KU( ~k.1 ) @ #vk.3 )
      next
        case responder
        by contradiction /* cyclic */
      qed
    next
      case split_case_3
      solve( !KU( h((~k.1⊕~na.1⊕nb.1)) ) @ #vk.1 )
        case c_h
        solve( !KU( (~k.1⊕~na.1⊕nb.1) ) @ #vk.3 )
          case c_xor_case_1
          solve( !KU( (~k.1⊕nb.1) ) @ #vk.4 )
            case c_xor
            by solve( !KU( ~k.1 ) @ #vk.7 )
          next
            case coerce
            solve( !KD( (~k.1⊕nb.1) ) ▶₀ #vk.4 )
              case initiator
              by contradiction /* impossible chain */
            next
              case responder
              solve( (#vl, 0) ~~> (#vk.4, 0) )
                case d_0_fst
                by solve( (#vr.3, 0) ~~> (#vk.4, 0) )
              next
                case d_0_snd
                by contradiction /* impossible chain */
              qed
            qed
          qed
        next
          case c_xor_case_2
          by solve( !KU( ~k.1 ) @ #vk.5 )
        next
          case c_xor_case_3
          solve( !KU( (~k.1⊕~na.1) ) @ #vk.5 )
            case c_xor
            by solve( !KU( ~k.1 ) @ #vk.7 )
          next
            case coerce
            solve( !KD( (~k.1⊕~na.1) ) ▶₀ #vk.5 )
              case initiator
              by contradiction /* impossible chain */
            next
              case responder
              solve( (#vl, 0) ~~> (#vk.5, 0) )
                case d_0_fst
                by solve( (#vr.3, 0) ~~> (#vk.5, 0) )
              next
                case d_0_snd
                by contradiction /* impossible chain */
              qed
            qed
          qed
        next
          case coerce
          solve( !KD( (~k.1⊕~na.1⊕nb.1) ) ▶₀ #vk.3 )
            case initiator
            by contradiction /* impossible chain */
          next
            case responder
            solve( (#vl, 0) ~~> (#vk.3, 0) )
              case d_0_fst
              by solve( (#vr.3, 0) ~~> (#vk.3, 0) )
            next
              case d_0_snd
              by contradiction /* impossible chain */
            qed
          qed
        qed
      next
        case responder
        by contradiction /* from formulas */
      qed
    next
      case split_case_4
      solve( !KU( h((~k.1⊕~na.1)) ) @ #vk.1 )
        case c_h
        solve( !KU( (~k.1⊕~na.1) ) @ #vk.3 )
          case c_xor
          by solve( !KU( ~k.1 ) @ #vk.5 )
        next
          case coerce
          solve( !KD( (~k.1⊕~na.1) ) ▶₀ #vk.3 )
            case initiator
            by contradiction /* impossible chain */
          next
            case responder
            solve( (#vl, 0) ~~> (#vk.3, 0) )
              case d_0_fst
              by solve( (#vr.3, 0) ~~> (#vk.3, 0) )
            next
              case d_0_snd
              by contradiction /* impossible chain */
            qed
          qed
        qed
      next
        case responder
        by contradiction /* from formulas */
      qed
    next
      case split_case_5
      solve( !KU( h((~k.1⊕x.1)) ) @ #vk.1 )
        case c_h
        solve( !KU( (~na.1⊕x.1) ) @ #vk.2 )
          case c_xor
          solve( !KU( (~k.1⊕x.1) ) @ #vk.3 )
            case c_xor
            by solve( !KU( ~k.1 ) @ #vk.7 )
          next
            case coerce
            solve( !KD( (~k.1⊕x.1) ) ▶₀ #vk.3 )
              case initiator
              by contradiction /* impossible chain */
            next
              case responder
              solve( (#vl, 0) ~~> (#vk.3, 0) )
                case d_0_fst
                by solve( (#vr.3, 0) ~~> (#vk.3, 0) )
              next
                case d_0_snd
                by contradiction /* impossible chain */
              qed
            qed
          qed
        next
          case coerce
          solve( !KD( (~na.1⊕x.1) ) ▶₀ #vk.2 )
            case initiator
            by contradiction /* impossible chain */
          next
            case responder
            solve( (#vl, 0) ~~> (#vk.2, 0) )
              case d_0_fst
              by solve( (#vr.3, 0) ~~> (#vk.2, 0) )
            next
              case d_0_snd
              by contradiction /* impossible chain */
            qed
          qed
        qed
      next
        case responder
        by contradiction /* from formulas */
      qed
    next
      case split_case_6
      solve( !KU( (~k.1⊕~na.1) ) @ #vk.2 )
        case c_xor
        by solve( !KU( ~k.1 ) @ #vk.4 )
      next
        case coerce
        solve( !KD( (~k.1⊕~na.1) ) ▶₀ #vk.2 )
          case initiator
          by contradiction /* impossible chain */
        next
          case responder
          solve( (#vl, 0) ~~> (#vk.2, 0) )
            case d_0_fst
            by solve( (#vr.3, 0) ~~> (#vk.2, 0) )
          next
            case d_0_snd
            by contradiction /* impossible chain */
          qed
        qed
      qed
    next
      case split_case_7
      solve( !KU( h((~na.1⊕x.1)) ) @ #vk.1 )
        case c_h
        solve( !KU( (~k.1⊕x.1) ) @ #vk.2 )
          case c_xor
          by solve( !KU( ~k.1 ) @ #vk.5 )
        next
          case coerce
          solve( !KD( (~k.1⊕x.1) ) ▶₀ #vk.2 )
            case initiator
            by contradiction /* impossible chain */
          next
            case responder
            solve( (#vl, 0) ~~> (#vk.2, 0) )
              case d_0_fst
              by solve( (#vr.3, 0) ~~> (#vk.2, 0) )
            next
              case d_0_snd
              by contradiction /* impossible chain */
            qed
          qed
        qed
      next
        case responder
        by contradiction /* from formulas */
      qed
    next
      case split_case_8
      solve( !KU( (~k.1⊕~na.1⊕z.1) ) @ #vk.2 )
        case c_xor_case_1
        solve( !KU( (~k.1⊕z.1) ) @ #vk.3 )
          case c_xor
          by solve( !KU( ~k.1 ) @ #vk.6 )
        next
          case coerce
          solve( !KD( (~k.1⊕z.1) ) ▶₀ #vk.3 )
            case initiator
            by contradiction /* impossible chain */
          next
            case responder
            solve( (#vl, 0) ~~> (#vk.3, 0) )
              case d_0_fst
              by solve( (#vr.3, 0) ~~> (#vk.3, 0) )
            next
              case d_0_snd
              by contradiction /* impossible chain */
            qed
          qed
        qed
      next
        case c_xor_case_2
        by solve( !KU( ~k.1 ) @ #vk.4 )
      next
        case c_xor_case_3
        solve( !KU( (~k.1⊕~na.1) ) @ #vk.4 )
          case c_xor
          by solve( !KU( ~k.1 ) @ #vk.6 )
        next
          case coerce
          solve( !KD( (~k.1⊕~na.1) ) ▶₀ #vk.4 )
            case initiator
            by contradiction /* impossible chain */
          next
            case responder
            solve( (#vl, 0) ~~> (#vk.4, 0) )
              case d_0_fst
              by solve( (#vr.3, 0) ~~> (#vk.4, 0) )
            next
              case d_0_snd
              by contradiction /* impossible chain */
            qed
          qed
        qed
      next
        case coerce
        solve( !KD( (~k.1⊕~na.1⊕z.1) ) ▶₀ #vk.2 )
          case initiator
          by contradiction /* impossible chain */
        next
          case responder
          solve( (#vl, 0) ~~> (#vk.2, 0) )
            case d_0_fst
            by solve( (#vr.3, 0) ~~> (#vk.2, 0) )
          next
            case d_0_snd
            by contradiction /* impossible chain */
          qed
        qed
      qed
    qed
  qed
qed

lemma recentalive_tag:
  all-traces
  "∀ x y #i.
    (Alive( x, y ) @ #i) ⇒
    (∃ #j #k.
      (((Challenge( x ) @ #k) ∧ (Response( y ) @ #j)) ∧ (#k < #j)) ∧
      (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ x y #i.
  (Alive( x, y ) @ #i)
 ∧
  ∀ #j #k.
   (Challenge( x ) @ #k) ∧ (Response( y ) @ #j)
  ⇒
   ((¬(#k < #j)) ∨ (¬(#j < #i)))"
*/
simplify
solve( Initiated( ~na ) ▶₀ #i )
  case initiator
  solve( !InitLTK( ~k ) ▶₁ #i )
    case Setup
    solve( splitEqs(0) )
      case split_case_5
      solve( !KU( h((~k.1⊕x.1)) ) @ #vk.1 )
        case responder
        solve( !KU( (~na.1⊕x.1) ) @ #vk.2 )
          case c_xor
          solve( splitEqs(2) )
            case split_case_2
            solve( !KU( (~nb.2⊕na.3) ) @ #vk.4 )
              case c_xor
              solve( !KU( ~na.1 ) @ #vk.5 )
                case initiator
                solve( !KU( ~nb.2 ) @ #vk.7 )
                  case responder
                  SOLVED // trace found
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma executable:
  exists-trace
  "∃ x y #i #j.
    (((Alive( x, y ) @ #i) ∧ (Response( y ) @ #j)) ∧
     (¬(∃ #k. (Response( y ) @ #k) ∧ (¬(#j = #k))))) ∧
    (¬(∃ #l. NeqForExec( x, x ) @ #l))"
/*
guarded formula characterizing all satisfying traces:
"∃ x y #i #j.
  (Alive( x, y ) @ #i) ∧ (Response( y ) @ #j)
 ∧
  (∀ #k. (Response( y ) @ #k) ⇒ #j = #k) ∧
  (∀ #l. (NeqForExec( x, x ) @ #l) ⇒ ⊥)"
*/
simplify
solve( Initiated( ~na ) ▶₀ #i )
  case initiator
  solve( !InitLTK( ~k.1 ) ▶₁ #i )
    case Setup
    solve( !RespLTK( ~k.1 ) ▶₂ #j )
      case Setup
      solve( splitEqs(0) )
        case split_case_3
        solve( !KU( h((~k.2⊕~na.2⊕nb.2)) ) @ #vk.1 )
          case responder
          solve( splitEqs(1) )
            case split_case_1
            solve( !KU( ~nb.4 ) @ #vk.2 )
              case responder
              solve( !KU( ~na.4 ) @ #vk.5 )
                case initiator
                SOLVED // trace found
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed









/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.11.0
Maude version 3.2.1
Git revision: d8e8266fc8aa702ff3c4d08608a7fbbe124eea65, branch: cyclic-squashed
Compiled at: 2024-11-27 09:37:37.786154 UTC
*/

end
/* Output

==============================================================================
summary of summaries:

analyzed: examples/csf18-xor/CRxor.spthy

  output:          examples/csf18-xor/CRxor.spthy.tmp
  processing time: 0.47s
  
  alive (all-traces): verified (92 steps)
  recentalive_tag (all-traces): falsified - found trace (11 steps)
  executable (exists-trace): verified (10 steps)

==============================================================================
*/
