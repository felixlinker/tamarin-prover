theory CH07 begin

// Function signature and definition of the equational theory E

builtins: xor
functions: fst/1, h/1, lh/1, pair/2, rh/1, rot/2, snd/1
equations: fst(<x.1, x.2>) = x.1, snd(<x.1, x.2>) = x.2









rule (modulo E) Setup:
   [ Fr( ~k ), Fr( ~id ) ] --> [ !Reader( ~k, ~id ), !Tag( ~k, ~id ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) reader1:
   [ Fr( ~r1 ) ]
  --[ Challenge( ~r1, 'Reader' ) ]->
   [ Out( ~r1 ), Initiated( ~r1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) tag1:
   [ In( r1 ), Fr( ~r2 ), !Tag( ~k, ~id ) ]
  --[
  Response( ~k, 'Tag' ), Challenge( ~r2, 'Tag' ),
  Running( <'R', 'T', (~k⊕~r2⊕r1)> )
  ]->
   [
   Out( <~r2, lh((h((~k⊕~r2⊕r1))⊕rot(~id, h((~k⊕~r2⊕r1)))))> ),
   TagState( ~k, r1, ~r2, h((~k⊕~r2⊕r1)) )
   ]

  /*
  rule (modulo AC) tag1:
     [ In( r1 ), Fr( ~r2 ), !Tag( ~k, ~id ) ]
    --[
    Response( ~k, 'Tag' ), Challenge( ~r2, 'Tag' ), Running( <'R', 'T', z> )
    ]->
     [ Out( <~r2, lh((h(z)⊕rot(~id, h(z))))> ), TagState( ~k, r1, ~r2, h(z) )
     ]
    variants (modulo AC)
    1. ~k    = ~k.3
       ~r2   = ~r2.3
       r1    = r1.3
       z     = (~k.3⊕~r2.3⊕r1.3)
    
    2. ~k    = ~k.3
       ~r2   = ~r2.3
       r1    = zero
       z     = (~k.3⊕~r2.3)
    
    3. ~k    = ~k.3
       ~r2   = ~x.8
       r1    = ~x.8
       z     = ~k.3
    
    4. ~k    = ~k.3
       ~r2   = ~x.9
       r1    = (~x.9⊕x.10)
       z     = (~k.3⊕x.10)
    
    5. ~k    = ~x.8
       ~r2   = ~r2.3
       r1    = ~x.8
       z     = ~r2.3
    
    6. ~k    = ~x.8
       ~r2   = ~x.8
       r1    = r1.3
       z     = r1.3
    
    7. ~k    = ~x.9
       ~r2   = ~x.10
       r1    = (~x.9⊕~x.10)
       z     = zero
    
    8. ~k    = ~x.10
       ~r2   = ~r2.3
       r1    = (~x.10⊕x.12)
       z     = (~r2.3⊕x.12)
    
    9. ~k    = ~x.10
       ~r2   = ~x.11
       r1    = (~x.10⊕~x.11⊕x.12)
       z     = x.12
  */

rule (modulo E) reader2:
   [
   Initiated( ~r1 ), !Reader( ~k, ~id ),
   In( <r2, lh((hash⊕rot(~id, hash)))> )
   ]
  --[
  Alive( ~k, 'Tag' ), Response( ~k, 'Reader' ), Eq( h((~k⊕~r1⊕r2)), hash ),
  Running( <'T', 'R', (~k⊕~r1⊕r2)> ), Commit( <'R', 'T', (~k⊕~r1⊕r2)> )
  ]->
   [ Out( rh((hash⊕rot(~id, hash))) ) ]

  /*
  rule (modulo AC) reader2:
     [ Initiated( ~r1 ), !Reader( ~k, ~id ), In( <r2, lh(z)> ) ]
    --[
    Alive( ~k, 'Tag' ), Response( ~k, 'Reader' ), Eq( h(z.1), hash ),
    Running( <'T', 'R', z.1> ), Commit( <'R', 'T', z.1> )
    ]->
     [ Out( rh(z) ) ]
    variants (modulo AC)
     1. ~id   = ~id.3
        ~k    = ~x.1
        ~r1   = ~x.1
        hash  = zero
        r2    = r2.3
        z     = rot(~id.3, zero)
        z.1   = r2.3
    
     2. ~id   = ~id.3
        ~k    = ~x.1
        ~r1   = ~r1.3
        hash  = zero
        r2    = ~x.1
        z     = rot(~id.3, zero)
        z.1   = ~r1.3
    
     3. ~id   = ~id.3
        ~k    = ~x.2
        ~r1   = ~x.3
        hash  = zero
        r2    = (~x.2⊕~x.3)
        z     = rot(~id.3, zero)
        z.1   = zero
    
     4. ~id   = ~id.3
        ~k    = ~k.3
        ~r1   = ~x.1
        hash  = zero
        r2    = ~x.1
        z     = rot(~id.3, zero)
        z.1   = ~k.3
    
     5. ~id   = ~id.3
        ~k    = ~k.3
        ~r1   = ~x.2
        hash  = zero
        r2    = (~x.2⊕x.3)
        z     = rot(~id.3, zero)
        z.1   = (~k.3⊕x.3)
    
     6. ~id   = ~id.3
        ~k    = ~k.3
        ~r1   = ~r1.3
        hash  = zero
        r2    = r2.3
        z     = rot(~id.3, zero)
        z.1   = (~k.3⊕~r1.3⊕r2.3)
    
     7. ~id   = ~id.3
        ~k    = ~k.3
        ~r1   = ~r1.3
        hash  = zero
        r2    = zero
        z     = rot(~id.3, zero)
        z.1   = (~k.3⊕~r1.3)
    
     8. ~id   = ~id.3
        ~k    = ~x.3
        ~r1   = ~r1.3
        hash  = zero
        r2    = (~x.3⊕x.5)
        z     = rot(~id.3, zero)
        z.1   = (~r1.3⊕x.5)
    
     9. ~id   = ~id.3
        ~k    = ~x.3
        ~r1   = ~x.4
        hash  = zero
        r2    = (~x.3⊕~x.4⊕x.5)
        z     = rot(~id.3, zero)
        z.1   = x.5
    
    10. ~id   = ~id.3
        ~k    = ~x.1
        ~r1   = ~x.1
        hash  = hash.3
        r2    = r2.3
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = r2.3
    
    11. ~id   = ~id.3
        ~k    = ~x.1
        ~r1   = ~r1.3
        hash  = hash.3
        r2    = ~x.1
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = ~r1.3
    
    12. ~id   = ~id.3
        ~k    = ~x.2
        ~r1   = ~x.3
        hash  = hash.3
        r2    = (~x.2⊕~x.3)
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = zero
    
    13. ~id   = ~id.3
        ~k    = ~k.3
        ~r1   = ~x.1
        hash  = hash.3
        r2    = ~x.1
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = ~k.3
    
    14. ~id   = ~id.3
        ~k    = ~k.3
        ~r1   = ~r1.3
        hash  = hash.3
        r2    = r2.3
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = (~k.3⊕~r1.3⊕r2.3)
    
    15. ~id   = ~id.3
        ~k    = ~k.3
        ~r1   = ~r1.3
        hash  = hash.3
        r2    = zero
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = (~k.3⊕~r1.3)
    
    16. ~id   = ~id.3
        ~k    = ~k.3
        ~r1   = ~x.3
        hash  = hash.3
        r2    = (~x.3⊕x.5)
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = (~k.3⊕x.5)
    
    17. ~id   = ~id.3
        ~k    = ~x.4
        ~r1   = ~r1.3
        hash  = hash.3
        r2    = (~x.4⊕x.7)
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = (~r1.3⊕x.7)
    
    18. ~id   = ~id.3
        ~k    = ~x.4
        ~r1   = ~x.5
        hash  = hash.3
        r2    = (~x.4⊕~x.5⊕x.7)
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = x.7
  */

rule (modulo E) tag2:
   [
   In( rh((hash⊕rot(~id, hash))) ), !Tag( ~k, ~id ),
   TagState( ~k, r1, ~r2, hash )
   ]
  --[ Alive( ~k, 'Reader' ), Commit( <'T', 'R', (~k⊕~r2⊕r1)> ) ]->
   [ ]

  /*
  rule (modulo AC) tag2:
     [ In( rh(z) ), !Tag( ~k, ~id ), TagState( ~k, r1, ~r2, hash ) ]
    --[ Alive( ~k, 'Reader' ), Commit( <'T', 'R', z.1> ) ]->
     [ ]
    variants (modulo AC)
     1. ~id   = ~id.3
        ~k    = ~x.1
        ~r2   = ~x.1
        hash  = zero
        r1    = r1.3
        z     = rot(~id.3, zero)
        z.1   = r1.3
    
     2. ~id   = ~id.3
        ~k    = ~x.1
        ~r2   = ~r2.3
        hash  = zero
        r1    = ~x.1
        z     = rot(~id.3, zero)
        z.1   = ~r2.3
    
     3. ~id   = ~id.3
        ~k    = ~x.2
        ~r2   = ~x.3
        hash  = zero
        r1    = (~x.2⊕~x.3)
        z     = rot(~id.3, zero)
        z.1   = zero
    
     4. ~id   = ~id.3
        ~k    = ~k.3
        ~r2   = ~x.1
        hash  = zero
        r1    = ~x.1
        z     = rot(~id.3, zero)
        z.1   = ~k.3
    
     5. ~id   = ~id.3
        ~k    = ~k.3
        ~r2   = ~x.2
        hash  = zero
        r1    = (~x.2⊕x.3)
        z     = rot(~id.3, zero)
        z.1   = (~k.3⊕x.3)
    
     6. ~id   = ~id.3
        ~k    = ~k.3
        ~r2   = ~r2.3
        hash  = zero
        r1    = r1.3
        z     = rot(~id.3, zero)
        z.1   = (~k.3⊕~r2.3⊕r1.3)
    
     7. ~id   = ~id.3
        ~k    = ~k.3
        ~r2   = ~r2.3
        hash  = zero
        r1    = zero
        z     = rot(~id.3, zero)
        z.1   = (~k.3⊕~r2.3)
    
     8. ~id   = ~id.3
        ~k    = ~x.3
        ~r2   = ~r2.3
        hash  = zero
        r1    = (~x.3⊕x.5)
        z     = rot(~id.3, zero)
        z.1   = (~r2.3⊕x.5)
    
     9. ~id   = ~id.3
        ~k    = ~x.3
        ~r2   = ~x.4
        hash  = zero
        r1    = (~x.3⊕~x.4⊕x.5)
        z     = rot(~id.3, zero)
        z.1   = x.5
    
    10. ~id   = ~id.3
        ~k    = ~x.1
        ~r2   = ~x.1
        hash  = hash.3
        r1    = r1.3
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = r1.3
    
    11. ~id   = ~id.3
        ~k    = ~x.1
        ~r2   = ~r2.3
        hash  = hash.3
        r1    = ~x.1
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = ~r2.3
    
    12. ~id   = ~id.3
        ~k    = ~x.2
        ~r2   = ~x.3
        hash  = hash.3
        r1    = (~x.2⊕~x.3)
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = zero
    
    13. ~id   = ~id.3
        ~k    = ~k.3
        ~r2   = ~x.1
        hash  = hash.3
        r1    = ~x.1
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = ~k.3
    
    14. ~id   = ~id.3
        ~k    = ~k.3
        ~r2   = ~r2.3
        hash  = hash.3
        r1    = r1.3
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = (~k.3⊕~r2.3⊕r1.3)
    
    15. ~id   = ~id.3
        ~k    = ~k.3
        ~r2   = ~r2.3
        hash  = hash.3
        r1    = zero
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = (~k.3⊕~r2.3)
    
    16. ~id   = ~id.3
        ~k    = ~k.3
        ~r2   = ~x.3
        hash  = hash.3
        r1    = (~x.3⊕x.5)
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = (~k.3⊕x.5)
    
    17. ~id   = ~id.3
        ~k    = ~x.4
        ~r2   = ~r2.3
        hash  = hash.3
        r1    = (~x.4⊕x.7)
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = (~r2.3⊕x.7)
    
    18. ~id   = ~id.3
        ~k    = ~x.4
        ~r2   = ~x.5
        hash  = hash.3
        r1    = (~x.4⊕~x.5⊕x.7)
        z     = (hash.3⊕rot(~id.3, hash.3))
        z.1   = x.7
  */

restriction equality:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

lemma recentalive_tag:
  all-traces
  "∀ x #i.
    (Alive( x, 'Tag' ) @ #i) ⇒
    (∃ y #j #k.
      (((Challenge( y, 'Reader' ) @ #k) ∧ (Response( x, 'Tag' ) @ #j)) ∧
       (#k < #j)) ∧
      (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ x #i.
  (Alive( x, 'Tag' ) @ #i)
 ∧
  ∀ y #j #k.
   (Challenge( y, 'Reader' ) @ #k) ∧ (Response( x, 'Tag' ) @ #j)
  ⇒
   ((¬(#k < #j)) ∨ (¬(#j < #i)))"
*/
simplify
solve( Alive( x, 'Tag' ) @ #i )
  case reader2
  solve( Initiated( ~r1 ) ▶₀ #i )
    case reader1
    solve( !Reader( ~k, ~id ) ▶₁ #i )
      case Setup
      solve( !KU( lh((h(z.1)⊕rot(~id, h(z.1)))) ) @ #vk.2 )
        case tag1
        solve( splitEqs(0) )
          case split_case_7
          solve( !KU( (~r1.2⊕x.8) ) @ #vk.1 )
            case c_xor
            solve( splitEqs(1) )
              case split_case_1
              solve( !KU( ~r1.2 ) @ #vk.5 )
                case reader1
                solve( !KU( ~r2.2 ) @ #vk.4 )
                  case tag1
                  SOLVED // trace found
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma recentalive_reader:
  all-traces
  "∀ x #i.
    (Alive( x, 'Reader' ) @ #i) ⇒
    (∃ y #j #k.
      (((Challenge( y, 'Tag' ) @ #k) ∧ (Response( x, 'Reader' ) @ #j)) ∧
       (#k < #j)) ∧
      (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ x #i.
  (Alive( x, 'Reader' ) @ #i)
 ∧
  ∀ y #j #k.
   (Challenge( y, 'Tag' ) @ #k) ∧ (Response( x, 'Reader' ) @ #j)
  ⇒
   ((¬(#k < #j)) ∨ (¬(#j < #i)))"
*/
simplify
solve( Alive( x, 'Reader' ) @ #i )
  case tag2
  solve( !Tag( ~k, ~id ) ▶₁ #i )
    case Setup
    solve( TagState( ~k, r1, ~r2, hash ) ▶₂ #i )
      case tag1
      solve( !KU( rh((h(z.2)⊕rot(~id.1, h(z.2)))) ) @ #vk )
        case c_rh
        solve( !KU( (h(z.2)⊕rot(~id.1, h(z.2))) ) @ #vk.2 )
          case c_xor
          solve( !KU( rot(~id.1, h(z.2)) ) @ #vk.3 )
            case c_rot
            by solve( !KU( ~id.1 ) @ #vk.5 )
          qed
        next
          case coerce
          solve( !KD( (h(z.2)⊕rot(~id.1, h(z.2))) ) ▶₀ #vk.2 )
            case reader1
            by contradiction /* impossible chain */
          next
            case reader2
            by solve( (#vl, 0) ~~> (#vk.2, 0) )
          next
            case tag1
            solve( (#vl, 0) ~~> (#vk.2, 0) )
              case d_0_fst
              by contradiction /* impossible chain */
            next
              case d_0_snd
              by solve( (#vr.4, 0) ~~> (#vk.2, 0) )
            qed
          qed
        qed
      next
        case reader2
        solve( !KU( lh((h(z.3)⊕rot(~id.2, h(z.3)))) ) @ #vk.4 )
          case c_lh
          solve( !KU( (h(z.3)⊕rot(~id.2, h(z.3))) ) @ #vk.5 )
            case c_xor
            solve( !KU( rot(~id.2, h(z.3)) ) @ #vk.6 )
              case c_rot
              by solve( !KU( ~id.2 ) @ #vk.8 )
            qed
          next
            case coerce
            solve( !KD( (h(z.3)⊕rot(~id.2, h(z.3))) ) ▶₀ #vk.5 )
              case reader1
              by contradiction /* impossible chain */
            next
              case reader2
              by solve( (#vl.1, 0) ~~> (#vk.5, 0) )
            next
              case tag1
              by contradiction /* from formulas */
            qed
          qed
        next
          case tag1
          by contradiction /* from formulas */
        qed
      qed
    qed
  qed
qed

lemma noninjectiveagreement_tag:
  all-traces
  "∀ t #i.
    (Commit( <'T', 'R', t> ) @ #i) ⇒ (∃ #j. Running( <'T', 'R', t> ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ t #i.
  (Commit( <'T', 'R', t> ) @ #i)
 ∧
  ∀ #j. (Running( <'T', 'R', t> ) @ #j) ⇒ ⊥"
*/
simplify
solve( Commit( <'T', 'R', t> ) @ #i )
  case tag2
  solve( !Tag( ~k, ~id ) ▶₁ #i )
    case Setup
    solve( TagState( ~k, r1, ~r2, hash ) ▶₂ #i )
      case tag1
      solve( !KU( rh((h(x.2)⊕rot(~id.1, h(x.2)))) ) @ #vk )
        case c_rh
        solve( !KU( (h(x.2)⊕rot(~id.1, h(x.2))) ) @ #vk.2 )
          case c_xor
          solve( !KU( rot(~id.1, h(x.2)) ) @ #vk.3 )
            case c_rot
            by solve( !KU( ~id.1 ) @ #vk.5 )
          qed
        next
          case coerce
          solve( !KD( (h(x.2)⊕rot(~id.1, h(x.2))) ) ▶₀ #vk.2 )
            case reader1
            by contradiction /* impossible chain */
          next
            case reader2
            by solve( (#vl, 0) ~~> (#vk.2, 0) )
          next
            case tag1
            solve( (#vl, 0) ~~> (#vk.2, 0) )
              case d_0_fst
              by contradiction /* impossible chain */
            next
              case d_0_snd
              by solve( (#vr.4, 0) ~~> (#vk.2, 0) )
            qed
          qed
        qed
      next
        case reader2
        solve( splitEqs(0) )
          case split_case_1
          by contradiction /* cyclic */
        next
          case split_case_2
          by contradiction /* from formulas */
        next
          case split_case_3
          by contradiction /* from formulas */
        next
          case split_case_4
          by contradiction /* from formulas */
        next
          case split_case_5
          solve( splitEqs(1) )
            case split
            by contradiction /* from formulas */
          qed
        next
          case split_case_6
          by contradiction /* from formulas */
        next
          case split_case_7
          solve( splitEqs(1) )
            case split
            by contradiction /* from formulas */
          qed
        next
          case split_case_8
          by contradiction /* from formulas */
        qed
      qed
    qed
  qed
qed

lemma noninjectiveagreement_reader:
  all-traces
  "∀ t #i.
    (Commit( <'R', 'T', t> ) @ #i) ⇒ (∃ #j. Running( <'R', 'T', t> ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ t #i.
  (Commit( <'R', 'T', t> ) @ #i)
 ∧
  ∀ #j. (Running( <'R', 'T', t> ) @ #j) ⇒ ⊥"
*/
simplify
solve( Commit( <'R', 'T', t> ) @ #i )
  case reader2
  solve( Initiated( ~r1 ) ▶₀ #i )
    case reader1
    solve( !Reader( ~k, ~id ) ▶₁ #i )
      case Setup
      solve( !KU( lh((h(z.1)⊕rot(~id, h(z.1)))) ) @ #vk.2 )
        case c_lh
        solve( !KU( (h(z.1)⊕rot(~id, h(z.1))) ) @ #vk.3 )
          case c_xor
          solve( !KU( rot(~id, h(z.1)) ) @ #vk.4 )
            case c_rot
            by solve( !KU( ~id ) @ #vk.6 )
          qed
        next
          case coerce
          solve( !KD( (h(z.1)⊕rot(~id, h(z.1))) ) ▶₀ #vk.3 )
            case reader1
            by contradiction /* impossible chain */
          next
            case reader2
            by solve( (#vl, 0) ~~> (#vk.3, 0) )
          next
            case tag1
            solve( (#vl, 0) ~~> (#vk.3, 0) )
              case d_0_fst
              by contradiction /* impossible chain */
            next
              case d_0_snd
              by solve( (#vr.3, 0) ~~> (#vk.3, 0) )
            qed
          qed
        qed
      next
        case tag1
        by contradiction /* from formulas */
      qed
    qed
  qed
qed

lemma executable:
  exists-trace
  "∃ x #i #j.
    ((Alive( x, 'Reader' ) @ #i) ∧ (Response( x, 'Tag' ) @ #j)) ∧
    (¬(∃ #k. (Response( x, 'Tag' ) @ #k) ∧ (¬(#j = #k))))"
/*
guarded formula characterizing all satisfying traces:
"∃ x #i #j.
  (Alive( x, 'Reader' ) @ #i) ∧ (Response( x, 'Tag' ) @ #j)
 ∧
  ∀ #k. (Response( x, 'Tag' ) @ #k) ⇒ #j = #k"
*/
simplify
solve( Alive( x, 'Reader' ) @ #i )
  case tag2
  solve( !Tag( ~k, ~id ) ▶₁ #i )
    case Setup
    solve( TagState( ~k, r1, ~r2, hash ) ▶₂ #i )
      case tag1
      solve( Response( ~k, 'Tag' ) @ #vr.1 )
        case tag1
        solve( !KU( rh((h(z.2)⊕rot(~id.1, h(z.2)))) ) @ #vk )
          case reader2
          solve( splitEqs(0) )
            case split_case_3
            solve( splitEqs(2) )
              case split_case_1
              solve( !KU( ~r1.4 ) @ #vk.1 )
                case reader1
                solve( !KU( ~r2.4 ) @ #vk.3 )
                  case tag1
                  solve( !KU( lh((h((~k.4⊕~r1.4⊕~r2.4))⊕rot(~id.3, h((~k.4⊕~r1.4⊕~r2.4)))))
                         ) @ #vk.4 )
                    case tag1
                    SOLVED // trace found
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed















/*
WARNING: the following wellformedness checks failed!

Message Derivation Checks
=========================

  The variables of the following rule(s) are not derivable from their premises, you may be performing unintended pattern matching.

Rule reader2: 
Failed to derive Variable(s): hash
*/

/*
Generated from:
Tamarin version 1.11.0
Maude version 3.2.1
Git revision: d8e8266fc8aa702ff3c4d08608a7fbbe124eea65, branch: cyclic-squashed
Compiled at: 2024-11-27 09:37:37.786154 UTC
*/

end
/* Output

==============================================================================
summary of summaries:

analyzed: examples/csf18-xor/CH07.spthy

  output:          examples/csf18-xor/CH07.spthy.tmp
  processing time: 0.54s
  
  WARNING: 1 wellformedness check failed!
           The analysis results might be wrong!
  
  recentalive_tag (all-traces): falsified - found trace (11 steps)
  recentalive_reader (all-traces): verified (23 steps)
  noninjectiveagreement_tag (all-traces): verified (25 steps)
  noninjectiveagreement_reader (all-traces): verified (15 steps)
  executable (exists-trace): verified (12 steps)

==============================================================================
*/
