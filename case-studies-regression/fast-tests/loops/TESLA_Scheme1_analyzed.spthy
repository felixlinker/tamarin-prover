theory TESLA_Scheme1 begin

// Function signature and definition of the equational theory E

functions: MAC/2, f/1, fst/1, pair/2, pk/1, sign/2, snd/1, true/0,
           verify/3
equations:
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true







rule (modulo E) Generate_Keypair:
   [ Fr( ~ltk ) ]
  -->
   [ !Ltk( $A, ~ltk ), !Pk( $A, pk(~ltk) ), Out( pk(~ltk) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_Ltk:
   [ !Ltk( A, ltk ) ] --[ RevealLtk( A ) ]-> [ Out( ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Sender_Setup:
   [ Fr( ~k1 ) ] --> [ Sender1( $S, ~k1 ), !Sender0a( $S, ~k1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Sender0a:
   [ !Sender0a( S, k1 ), In( <R, S, nR> ), !Ltk( S, ltkS ) ]
  -->
   [ Out( <S, R, f(k1), sign(<f(k1), nR>, ltkS)> ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Receiver0a:
   [ Fr( ~nR ) ] --> [ Out( <$R, $S, ~nR> ), Receiver0b( ~nR, $R, $S ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Receiver0b:
   [
   Receiver0b( nR, R, S ), !Pk( S, pkS ),
   In( <S, R, commit_k1, signature> ), Fr( ~rid )
   ]
  --[ Setup( ~rid ) ]->
   [
   Receiver0b_check( ~rid, S, commit_k1,
                     verify(signature, <commit_k1, nR>, pkS)
   )
   ]

  /*
  rule (modulo AC) Receiver0b:
     [
     Receiver0b( nR, R, S ), !Pk( S, pkS ),
     In( <S, R, commit_k1, signature> ), Fr( ~rid )
     ]
    --[ Setup( ~rid ) ]->
     [ Receiver0b_check( ~rid, S, commit_k1, z ) ]
    variants (modulo AC)
    1. commit_k1
             = x
       nR    = x.1
       pkS   = pk(x.2)
       signature
             = sign(<x, x.1>, x.2)
       z     = true
    
    2. commit_k1
             = commit_k1.2
       nR    = nR.2
       pkS   = pkS.2
       signature
             = signature.2
       z     = verify(signature.2, <commit_k1.2, nR.2>, pkS.2)
  */

rule (modulo E) Receiver0b_check:
   [ Receiver0b_check( nR, S, commit_k1, true ), Fr( ~rid ) ]
  -->
   [ Receiver1( nR, S, commit_k1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Send1:
   [ Sender1( S, ~k1 ), Fr( ~m1 ), Fr( ~k2 ) ]
  --[ Sent( S, <~m1, f(~k2)> ) ]->
   [ Sender( S, ~k1, ~k2 ), Out( <<~m1, f(~k2)>, MAC(<~m1, f(~k2)>, ~k1)> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Recv1:
   [ Receiver1( rid, S, commit_k1 ), In( <<m1, commit_k2>, mac1> ) ]
  --[ AssumeCommitNotExpired( rid, commit_k1 ) ]->
   [ Receiver( rid, S, <m1, commit_k2>, mac1, commit_k1, commit_k2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) SendN:
   [ Sender( S, ~kOld, ~k ), Fr( ~m ), Fr( ~kNew ) ]
  --[ Sent( S, <~m, f(~kNew), ~kOld> ), CommitExpired( f(~kOld) ) ]->
   [
   Sender( S, ~k, ~kNew ),
   Out( <<~m, f(~kNew), ~kOld>, MAC(<~m, f(~kNew), ~kOld>, ~k)> )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) RecvN:
   [
   In( <<m, commit_kNew, kOld>, mac> ),
   Receiver( rid, S, dataOld, MAC(dataOld, kOld), f(kOld), commit_k )
   ]
  --[
  FromSender( rid, S, dataOld ), AssumeCommitNotExpired( rid, commit_k )
  ]->
   [ Receiver( rid, S, <m, commit_kNew, kOld>, mac, commit_k, commit_kNew )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

lemma authentic [use_induction]:
  all-traces
  "∀ rid S m #i.
    (FromSender( rid, S, m ) @ #i) ⇒
    (((∃ #j. (Sent( S, m ) @ #j) ∧ (#j < #i)) ∨
      (∃ #s #j. ((Setup( rid ) @ #s) ∧ (RevealLtk( S ) @ #j)) ∧ (#j < #s))) ∨
     (∃ commit #ne #e.
       (((AssumeCommitNotExpired( rid, commit ) @ #ne) ∧
         (CommitExpired( commit ) @ #e)) ∧
        (#e < #ne)) ∧
       (#ne < #i)))"
/*
guarded formula characterizing all counter-examples:
"∃ rid S m #i.
  (FromSender( rid, S, m ) @ #i)
 ∧
  (∀ #j. (Sent( S, m ) @ #j) ⇒ ¬(#j < #i)) ∧
  (∀ #s #j. (Setup( rid ) @ #s) ∧ (RevealLtk( S ) @ #j) ⇒ ¬(#j < #s)) ∧
  (∀ commit #ne #e.
    (AssumeCommitNotExpired( rid, commit ) @ #ne) ∧
    (CommitExpired( commit ) @ #e)
   ⇒
    ((¬(#e < #ne)) ∨ (¬(#ne < #i))))"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  solve( (last(#i))  ∥
         (∃ #j. (Sent( S.1, dataOld ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i))  ∥
         (∃ #s #j.
           (Setup( rid.1 ) @ #s) ∧ (RevealLtk( S.1 ) @ #j)
          ∧
           (¬(last(#j))) ∧ (¬(last(#s))) ∧ (#j < #s))  ∥
         (∃ commit #ne #e.
           (AssumeCommitNotExpired( rid.1, commit ) @ #ne) ∧
           (CommitExpired( commit ) @ #e)
          ∧
           (¬(last(#e))) ∧ (¬(last(#ne))) ∧ (#e < #ne) ∧ (#ne < #i)) )
    case case_1
    solve( Receiver( rid.1, S.1, dataOld, MAC(dataOld, kOld), f(kOld),
                     commit_k
           ) ▶₁ #i )
      case Recv1
      solve( !KU( sign(<f(kOld), ~nR>, ~ltk) ) @ #vk.18 )
        case Sender0a
        solve( !KU( ~k1 ) @ #vk.5 )
          case SendN
          solve( !KU( MAC(<m1, commit_k>, ~k1) ) @ #vk.11 )
            case Send1
            by contradiction /* from formulas */
          next
            case SendN
            solve( Sender( S.4, ~k1, ~k ) ▶₀ #vr.11 )
              case Send1
              by solve( Sender( S.5, ~kOld.1, ~k1 ) ▶₀ #vr.15 )
            next
              case SendN
              by solve( Sender( S.5, ~kOld.1, ~k1 ) ▶₀ #vr.15 )
            qed
          next
            case c_MAC
            by contradiction /* cyclic */
          qed
        qed
      next
        case c_sign
        solve( !KU( ~ltk ) @ #vk.20 )
          case Reveal_Ltk
          by contradiction /* from formulas */
        next
          case SendN
          solve( Sender( S.3, ~ltk, ~k ) ▶₀ #vr.5 )
            case SendN
            by solve( Sender( S.3, ~kOld.1, ~ltk ) ▶₀ #vr.9 )
          qed
        qed
      qed
    next
      case RecvN
      solve( (∃ #j.
               (Sent( S.1, dataOld.1 ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr))  ∥
             (∃ #s #j.
               (Setup( rid.1 ) @ #s) ∧ (RevealLtk( S.1 ) @ #j)
              ∧
               (¬(last(#j))) ∧ (¬(last(#s))) ∧ (#j < #s))  ∥
             (∃ commit #ne #e.
               (AssumeCommitNotExpired( rid.1, commit ) @ #ne) ∧
               (CommitExpired( commit ) @ #e)
              ∧
               (¬(last(#e))) ∧ (¬(last(#ne))) ∧ (#e < #ne) ∧ (#ne < #vr)) )
        case case_1
        solve( Sent( S.1, dataOld.1 ) @ #j )
          case Send1
          solve( Sender1( S.2, ~k1 ) ▶₀ #j )
            case Sender_Setup
            solve( Receiver( rid.1, $S.3, <~m1, f(~k2)>, MAC(<~m1, f(~k2)>, kOld.1),
                             f(kOld.1), f(kOld)
                   ) ▶₁ #vr )
              case Recv1
              solve( !KU( ~k2 ) @ #vk.5 )
                case SendN
                solve( !KU( sign(<f(kOld.1), ~nR>, ~ltk) ) @ #vk.25 )
                  case Sender0a
                  solve( !KU( ~k1.1 ) @ #vk.12 )
                    case SendN
                    solve( !KU( MAC(<m.2, commit_k, ~k1.1>, ~k2) ) @ #vk.13 )
                      case SendN
                      solve( !KU( MAC(<~m1, f(~k2)>, ~k1.1) ) @ #vk.18 )
                        case Send1
                        solve( Sender( S.4, ~k2, ~k ) ▶₀ #vr.7 )
                          case SendN
                          solve( Sender( S.6, ~k1.1, ~k.1 ) ▶₀ #vr.17 )
                            case Send1
                            solve( Sender( S.7, ~k1.1, ~k.1 ) ▶₀ #vr.21 )
                              case Send1
                              by contradiction /* from formulas */
                            qed
                          next
                            case SendN
                            solve( Sender( S.7, ~k1.1, ~k2 ) ▶₀ #vr.21 )
                              case Send1
                              by contradiction /* from formulas */
                            qed
                          qed
                        qed
                      next
                        case c_MAC
                        by contradiction /* cyclic */
                      qed
                    next
                      case c_MAC
                      by contradiction /* cyclic */
                    qed
                  qed
                next
                  case c_sign
                  solve( !KU( ~ltk ) @ #vk.27 )
                    case Reveal_Ltk
                    by contradiction /* from formulas */
                  next
                    case SendN
                    solve( !KU( MAC(<m.2, commit_k, kOld.1>, ~k2) ) @ #vk.13 )
                      case SendN
                      solve( !KU( MAC(<~m1, f(~k2)>, ~kOld.2) ) @ #vk.18 )
                        case Send1
                        solve( !KU( f(~kOld.2) ) @ #vk.28 )
                          case Sender0a
                          solve( Sender( S.4, ~k2, ~k ) ▶₀ #vr.7 )
                            case SendN
                            solve( Sender( S.5, ~ltk, ~k.1 ) ▶₀ #vr.11 )
                              case SendN
                              solve( Sender( S.6, ~kOld.2, ~k2 ) ▶₀ #vr.15 )
                                case Send1
                                by contradiction /* from formulas */
                              qed
                            qed
                          qed
                        next
                          case c_f
                          solve( !KU( ~kOld.2 ) @ #vk.30 )
                            case SendN
                            by contradiction /* from formulas */
                          qed
                        qed
                      next
                        case c_MAC
                        solve( !KU( ~kOld.2 ) @ #vk.31 )
                          case Receiver0a
                          solve( !KU( f(~kOld.2) ) @ #vk.28 )
                            case c_f
                            solve( Sender( S.4, ~k2, ~k ) ▶₀ #vr.7 )
                              case SendN
                              solve( Sender( S.5, ~ltk, ~k.1 ) ▶₀ #vr.11 )
                                case SendN
                                by solve( Sender( S.6, ~kOld.2, ~k2 ) ▶₀ #vr.15 )
                              qed
                            qed
                          qed
                        next
                          case Reveal_Ltk
                          solve( !KU( f(~kOld.2) ) @ #vk.28 )
                            case c_f
                            solve( Sender( S.4, ~k2, ~k ) ▶₀ #vr.7 )
                              case SendN
                              solve( Sender( S.5, ~ltk, ~k.1 ) ▶₀ #vr.11 )
                                case SendN
                                by solve( Sender( S.6, ~kOld.2, ~k2 ) ▶₀ #vr.15 )
                              qed
                            qed
                          qed
                        next
                          case Send1
                          solve( !KU( f(~kOld.2) ) @ #vk.28 )
                            case c_f
                            solve( Sender( S.4, ~k2, ~k ) ▶₀ #vr.7 )
                              case SendN
                              solve( Sender( S.5, ~ltk, ~k.1 ) ▶₀ #vr.11 )
                                case SendN
                                by solve( Sender( S.6, ~kOld.2, ~k2 ) ▶₀ #vr.15 )
                              qed
                            qed
                          qed
                        next
                          case SendN_case_1
                          solve( !KU( f(~kOld.2) ) @ #vk.28 )
                            case c_f
                            solve( Sender( S.4, ~k2, ~k ) ▶₀ #vr.7 )
                              case SendN
                              solve( Sender( S.5, ~ltk, ~k.1 ) ▶₀ #vr.11 )
                                case SendN
                                by solve( Sender( S.6, ~kOld.2, ~k2 ) ▶₀ #vr.15 )
                              qed
                            qed
                          qed
                        next
                          case SendN_case_2
                          by contradiction /* from formulas */
                        next
                          case fresh
                          solve( !KU( f(~kOld.2) ) @ #vk.28 )
                            case c_f
                            solve( Sender( S.4, ~k2, ~k ) ▶₀ #vr.7 )
                              case SendN
                              solve( Sender( S.5, ~ltk, ~k.1 ) ▶₀ #vr.11 )
                                case SendN
                                by solve( Sender( S.6, ~kOld.2, ~k2 ) ▶₀ #vr.15 )
                              qed
                            qed
                          qed
                        qed
                      qed
                    next
                      case c_MAC
                      by contradiction /* cyclic */
                    qed
                  qed
                qed
              qed
            qed
          qed
        next
          case SendN
          solve( Receiver( rid.1, S.2, <~m.3, f(~kNew), ~kOld.2>,
                           MAC(<~m.3, f(~kNew), ~kOld.2>, kOld.1), f(kOld.1), f(kOld)
                 ) ▶₁ #vr )
            case RecvN
            solve( (∃ #j.
                     (Sent( S.2, dataOld.2 ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
                   (∃ #s #j.
                     (Setup( rid.1 ) @ #s) ∧ (RevealLtk( S.2 ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (¬(last(#s))) ∧ (#j < #s))  ∥
                   (∃ commit #ne #e.
                     (AssumeCommitNotExpired( rid.1, commit ) @ #ne) ∧
                     (CommitExpired( commit ) @ #e)
                    ∧
                     (¬(last(#e))) ∧ (¬(last(#ne))) ∧ (#e < #ne) ∧ (#ne < #vr.1)) )
              case case_1
              solve( Sent( S.2, dataOld.2 ) @ #j.1 )
                case Send1
                solve( Sender1( S.3, ~k1 ) ▶₀ #j.1 )
                  case Sender_Setup
                  solve( !KU( ~kNew ) @ #vk.5 )
                    case SendN
                    solve( !KU( MAC(<m.2, commit_k, kOld.1>, ~kNew) ) @ #vk.13 )
                      case SendN
                      solve( !KU( MAC(<~m.3, f(~kNew), ~kOld.2>, ~kOld.3) ) @ #vk.20 )
                        case SendN
                        solve( Sender( $S.4, ~kOld.2, ~kOld.3 ) ▶₀ #vr.9 )
                          case Send1
                          solve( Receiver( rid.1, $S.4, <~m1, f(~k2)>, MAC(<~m1, f(~k2)>, ~kOld.2),
                                           f(~kOld.2), f(~kOld.3)
                                 ) ▶₁ #vr.1 )
                            case Recv1
                            solve( !KU( sign(<f(~kOld.2), ~nR>, ~ltk) ) @ #vk.32 )
                              case Sender0a
                              solve( Sender( S.5, ~kNew, ~k.1 ) ▶₀ #vr.3 )
                                case SendN
                                solve( Sender( S.6, ~kOld.3, ~kNew ) ▶₀ #vr.7 )
                                  case SendN
                                  by contradiction /* from formulas */
                                qed
                              qed
                            next
                              case c_sign
                              solve( !KU( ~ltk ) @ #vk.34 )
                                case Reveal_Ltk
                                by contradiction /* from formulas */
                              next
                                case SendN
                                solve( !KU( f(~kOld.2) ) @ #vk.35 )
                                  case Sender0a
                                  solve( Sender( S.5, ~kNew, ~k.1 ) ▶₀ #vr.3 )
                                    case SendN
                                    solve( Sender( S.6, ~kOld.3, ~kNew ) ▶₀ #vr.7 )
                                      case SendN
                                      by contradiction /* from formulas */
                                    qed
                                  qed
                                next
                                  case c_f
                                  solve( !KU( ~kOld.2 ) @ #vk.37 )
                                    case SendN
                                    by contradiction /* from formulas */
                                  qed
                                qed
                              qed
                            qed
                          qed
                        next
                          case SendN
                          by solve( Receiver( rid.1, $S.4, <~m1, f(~k2)>,
                                              MAC(<~m1, f(~k2)>, ~kOld.2), f(~kOld.2), f(~kOld.3)
                                    ) ▶₁ #vr.1 )
                        qed
                      next
                        case c_MAC
                        solve( !KU( ~kOld.3 ) @ #vk.22 )
                          case Receiver0a
                          solve( Sender( $S.4, ~kOld.2, ~k ) ▶₀ #j )
                            case Send1
                            by solve( Receiver( rid.1, $S.4, <~m1, f(~k2)>,
                                                MAC(<~m1, f(~k2)>, ~kOld.2), f(~kOld.2), f(~kOld.3)
                                      ) ▶₁ #vr.1 )
                          next
                            case SendN
                            by solve( Receiver( rid.1, $S.4, <~m1, f(~k2)>,
                                                MAC(<~m1, f(~k2)>, ~kOld.2), f(~kOld.2), f(~kOld.3)
                                      ) ▶₁ #vr.1 )
                          qed
                        next
                          case Reveal_Ltk
                          solve( Sender( $S.4, ~kOld.2, ~k ) ▶₀ #j )
                            case Send1
                            by solve( Receiver( rid.1, $S.4, <~m1, f(~k2)>,
                                                MAC(<~m1, f(~k2)>, ~kOld.2), f(~kOld.2), f(~kOld.3)
                                      ) ▶₁ #vr.1 )
                          next
                            case SendN
                            by solve( Receiver( rid.1, $S.4, <~m1, f(~k2)>,
                                                MAC(<~m1, f(~k2)>, ~kOld.2), f(~kOld.2), f(~kOld.3)
                                      ) ▶₁ #vr.1 )
                          qed
                        next
                          case Send1
                          solve( Sender( $S.4, ~kOld.2, ~k ) ▶₀ #j )
                            case Send1
                            by solve( Receiver( rid.1, $S.4, <~m1, f(~k2)>,
                                                MAC(<~m1, f(~k2)>, ~kOld.2), f(~kOld.2), f(~kOld.3)
                                      ) ▶₁ #vr.1 )
                          next
                            case SendN
                            by solve( Receiver( rid.1, $S.4, <~m1, f(~k2)>,
                                                MAC(<~m1, f(~k2)>, ~kOld.2), f(~kOld.2), f(~kOld.3)
                                      ) ▶₁ #vr.1 )
                          qed
                        next
                          case SendN_case_1
                          solve( Sender( $S.4, ~kOld.2, ~k ) ▶₀ #j )
                            case Send1
                            by solve( Receiver( rid.1, $S.4, <~m1, f(~k2)>,
                                                MAC(<~m1, f(~k2)>, ~kOld.2), f(~kOld.2), f(~kOld.3)
                                      ) ▶₁ #vr.1 )
                          next
                            case SendN
                            by solve( Receiver( rid.1, $S.4, <~m1, f(~k2)>,
                                                MAC(<~m1, f(~k2)>, ~kOld.2), f(~kOld.2), f(~kOld.3)
                                      ) ▶₁ #vr.1 )
                          qed
                        next
                          case SendN_case_2
                          by contradiction /* from formulas */
                        next
                          case fresh
                          solve( Sender( $S.4, ~kOld.2, ~k ) ▶₀ #j )
                            case Send1
                            by solve( Receiver( rid.1, $S.4, <~m1, f(~k2)>,
                                                MAC(<~m1, f(~k2)>, ~kOld.2), f(~kOld.2), f(~kOld.3)
                                      ) ▶₁ #vr.1 )
                          next
                            case SendN
                            by solve( Receiver( rid.1, $S.4, <~m1, f(~k2)>,
                                                MAC(<~m1, f(~k2)>, ~kOld.2), f(~kOld.2), f(~kOld.3)
                                      ) ▶₁ #vr.1 )
                          qed
                        qed
                      qed
                    next
                      case c_MAC
                      by contradiction /* cyclic */
                    qed
                  qed
                qed
              next
                case SendN
                solve( !KU( ~kNew ) @ #vk.5 )
                  case SendN
                  solve( !KU( MAC(<m.2, commit_k, kOld.1>, ~kNew) ) @ #vk.13 )
                    case SendN
                    solve( !KU( MAC(<~m.3, f(~kNew), ~kOld.2>, ~kOld.4) ) @ #vk.20 )
                      case SendN
                      solve( Sender( S.6, ~kOld.2, ~kOld.4 ) ▶₀ #vr.8 )
                        case Send1
                        by solve( Receiver( rid.1, $S.7, <~m.4, f(~kNew.1), ~kOld.3>,
                                            MAC(<~m.4, f(~kNew.1), ~kOld.3>, ~kOld.2), f(~kOld.2), f(~kOld.4)
                                  ) ▶₁ #vr.1 )
                      next
                        case SendN
                        solve( Receiver( rid.1, S.6, <~m.4, f(~kNew.1), ~kOld.3>,
                                         MAC(<~m.4, f(~kNew.1), ~kOld.3>, ~kOld.2), f(~kOld.2), f(~kOld.4)
                               ) ▶₁ #vr.1 )
                          case RecvN
                          solve( (∃ #j.
                                   (Sent( S.6, dataOld.3 ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.11))  ∥
                                 (∃ #s #j.
                                   (Setup( rid.1 ) @ #s) ∧ (RevealLtk( S.6 ) @ #j)
                                  ∧
                                   (¬(last(#j))) ∧ (¬(last(#s))) ∧ (#j < #s))  ∥
                                 (∃ commit #ne #e.
                                   (AssumeCommitNotExpired( rid.1, commit ) @ #ne) ∧
                                   (CommitExpired( commit ) @ #e)
                                  ∧
                                   (¬(last(#e))) ∧ (¬(last(#ne))) ∧ (#e < #ne) ∧ (#ne < #vr.11)) )
                            case case_1
                            solve( Sent( S.6, dataOld.3 ) @ #j.2 )
                              case Send1
                              solve( Sender1( S.7, ~k1 ) ▶₀ #j.2 )
                                case Sender_Setup
                                solve( Sender( $S.8, ~kOld.5, ~kOld.2 ) ▶₀ #vr.10 )
                                  case Send1
                                  solve( Sender( S.4, ~kNew, ~k.2 ) ▶₀ #vr.2 )
                                    case SendN
                                    solve( Sender( S.5, ~kOld.4, ~kNew ) ▶₀ #vr.6 )
                                      case SendN
                                      by contradiction /* from formulas */
                                    qed
                                  qed
                                next
                                  case SendN
                                  solve( Sender( S.4, ~kNew, ~k.2 ) ▶₀ #vr.2 )
                                    case SendN
                                    solve( Sender( S.5, ~kOld.4, ~kNew ) ▶₀ #vr.6 )
                                      case SendN
                                      by contradiction /* from formulas */
                                    qed
                                  qed
                                qed
                              qed
                            next
                              case SendN
                              solve( Sender( S.7, ~kOld.5, ~kOld.2 ) ▶₀ #vr.10 )
                                case Send1
                                solve( Sender( S.4, ~kNew, ~k.2 ) ▶₀ #vr.2 )
                                  case SendN
                                  solve( Sender( S.5, ~kOld.4, ~kNew ) ▶₀ #vr.6 )
                                    case SendN
                                    by contradiction /* from formulas */
                                  qed
                                qed
                              next
                                case SendN
                                solve( Sender( S.4, ~kNew, ~k.2 ) ▶₀ #vr.2 )
                                  case SendN
                                  solve( Sender( S.5, ~kOld.4, ~kNew ) ▶₀ #vr.6 )
                                    case SendN
                                    by contradiction /* from formulas */
                                  qed
                                qed
                              qed
                            qed
                          next
                            case case_2
                            by contradiction /* from formulas */
                          next
                            case case_3
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    next
                      case c_MAC
                      solve( !KU( ~kOld.4 ) @ #vk.22 )
                        case Receiver0a
                        solve( Sender( S.3, ~kOld.2, ~k ) ▶₀ #j )
                          case Send1
                          by solve( Receiver( rid.1, $S.7, <~m.4, f(~kNew.1), ~kOld.3>,
                                              MAC(<~m.4, f(~kNew.1), ~kOld.3>, ~kOld.2), f(~kOld.2),
                                              f(~kOld.4)
                                    ) ▶₁ #vr.1 )
                        next
                          case SendN
                          by solve( Receiver( rid.1, S.3, <~m.4, f(~kNew.1), ~kOld.3>,
                                              MAC(<~m.4, f(~kNew.1), ~kOld.3>, ~kOld.2), f(~kOld.2),
                                              f(~kOld.4)
                                    ) ▶₁ #vr.1 )
                        qed
                      next
                        case Reveal_Ltk
                        solve( Sender( S.3, ~kOld.2, ~k ) ▶₀ #j )
                          case Send1
                          by solve( Receiver( rid.1, $S.6, <~m.4, f(~kNew.1), ~kOld.3>,
                                              MAC(<~m.4, f(~kNew.1), ~kOld.3>, ~kOld.2), f(~kOld.2),
                                              f(~kOld.4)
                                    ) ▶₁ #vr.1 )
                        next
                          case SendN
                          by solve( Receiver( rid.1, S.3, <~m.4, f(~kNew.1), ~kOld.3>,
                                              MAC(<~m.4, f(~kNew.1), ~kOld.3>, ~kOld.2), f(~kOld.2),
                                              f(~kOld.4)
                                    ) ▶₁ #vr.1 )
                        qed
                      next
                        case Send1
                        solve( Sender( S.3, ~kOld.2, ~k ) ▶₀ #j )
                          case Send1
                          by solve( Receiver( rid.1, $S.7, <~m.4, f(~kNew.1), ~kOld.3>,
                                              MAC(<~m.4, f(~kNew.1), ~kOld.3>, ~kOld.2), f(~kOld.2),
                                              f(~kOld.4)
                                    ) ▶₁ #vr.1 )
                        next
                          case SendN
                          by solve( Receiver( rid.1, S.3, <~m.4, f(~kNew.1), ~kOld.3>,
                                              MAC(<~m.4, f(~kNew.1), ~kOld.3>, ~kOld.2), f(~kOld.2),
                                              f(~kOld.4)
                                    ) ▶₁ #vr.1 )
                        qed
                      next
                        case SendN_case_1
                        solve( Sender( S.3, ~kOld.2, ~k ) ▶₀ #j )
                          case Send1
                          by solve( Receiver( rid.1, $S.7, <~m.4, f(~kNew.1), ~kOld.3>,
                                              MAC(<~m.4, f(~kNew.1), ~kOld.3>, ~kOld.2), f(~kOld.2),
                                              f(~kOld.4)
                                    ) ▶₁ #vr.1 )
                        next
                          case SendN
                          by solve( Receiver( rid.1, S.3, <~m.4, f(~kNew.1), ~kOld.3>,
                                              MAC(<~m.4, f(~kNew.1), ~kOld.3>, ~kOld.2), f(~kOld.2),
                                              f(~kOld.4)
                                    ) ▶₁ #vr.1 )
                        qed
                      next
                        case SendN_case_2
                        by contradiction /* from formulas */
                      next
                        case fresh
                        solve( Sender( S.3, ~kOld.2, ~k ) ▶₀ #j )
                          case Send1
                          by solve( Receiver( rid.1, $S.6, <~m.4, f(~kNew.1), ~kOld.3>,
                                              MAC(<~m.4, f(~kNew.1), ~kOld.3>, ~kOld.2), f(~kOld.2),
                                              f(~kOld.4)
                                    ) ▶₁ #vr.1 )
                        next
                          case SendN
                          by solve( Receiver( rid.1, S.3, <~m.4, f(~kNew.1), ~kOld.3>,
                                              MAC(<~m.4, f(~kNew.1), ~kOld.3>, ~kOld.2), f(~kOld.2),
                                              f(~kOld.4)
                                    ) ▶₁ #vr.1 )
                        qed
                      qed
                    qed
                  next
                    case c_MAC
                    by contradiction /* cyclic */
                  qed
                qed
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        by contradiction /* from formulas */
      qed
    qed
  next
    case case_2
    by contradiction /* from formulas */
  next
    case case_3
    by contradiction /* from formulas */
  next
    case case_4
    by contradiction /* from formulas */
  qed
qed

lemma authentic_reachable [use_induction]:
  exists-trace
  "(∀ rid commit #i #j.
     ((AssumeCommitNotExpired( rid, commit ) @ #i) ∧
      (CommitExpired( commit ) @ #j)) ⇒
     (#i < #j)) ∧
   (∃ rid S m #i. FromSender( rid, S, m ) @ #i)"
/*
guarded formula characterizing all satisfying traces:
"(∀ rid commit #i #j.
   (AssumeCommitNotExpired( rid, commit ) @ #i) ∧
   (CommitExpired( commit ) @ #j)
  ⇒
   #i < #j) ∧
 (∃ rid S m #i. (FromSender( rid, S, m ) @ #i))"
*/
induction
  case non_empty_trace
  solve( (∃ rid commit #i #j.
           (AssumeCommitNotExpired( rid, commit ) @ #i) ∧
           (CommitExpired( commit ) @ #j)
          ∧
           (¬(last(#j))) ∧ (¬(last(#i))) ∧ (((#i = #j) ∨ (#j < #i))))  ∥
         (∀ rid S m #i. (FromSender( rid, S, m ) @ #i) ⇒ last(#i)) )
    case case_2
    solve( Receiver( rid.1, S.1, dataOld, MAC(dataOld, kOld), f(kOld),
                     commit_k
           ) ▶₁ #i )
      case Recv1
      solve( !KU( sign(<f(kOld), ~nR>, ~ltk) ) @ #vk.18 )
        case Sender0a
        solve( !KU( ~k1 ) @ #vk.5 )
          case SendN
          solve( !KU( MAC(<m1, commit_k>, ~k1) ) @ #vk.11 )
            case Send1
            solve( Sender( S.4, ~k1, ~k ) ▶₀ #vr.11 )
              case Send1
              solve( !KU( ~nR ) @ #vk.23 )
                case Receiver0a
                solve( !KU( ~m1.2 ) @ #vk.9 )
                  case Send1
                  solve( !KU( f(~k1.1) ) @ #vk.17 )
                    case Sender0a
                    solve( !KU( f(~k2.1) ) @ #vk.10 )
                      case Send1
                      SOLVED // trace found
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed



















/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.11.0
Maude version 3.2.1
Git revision: d8e8266fc8aa702ff3c4d08608a7fbbe124eea65, branch: cyclic-squashed
Compiled at: 2024-11-27 09:37:37.786154 UTC
*/

end
/* Output

==============================================================================
summary of summaries:

analyzed: examples/loops/TESLA_Scheme1.spthy

  output:          examples/loops/TESLA_Scheme1.spthy.tmp
  processing time: 1.23s
  
  authentic (all-traces): verified (157 steps)
  authentic_reachable (exists-trace): verified (12 steps)

==============================================================================
*/
