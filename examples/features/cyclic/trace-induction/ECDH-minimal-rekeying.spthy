theory ECDHMinimalRekeying
begin

builtins: diffie-hellman, symmetric-encryption
functions: kdf/1, decrypts/2, true/0
equations: decrypts(senc(m, k), k) = true

restriction Eq:
  "All a b #x. Eq(a, b) @ #x ==> a = b"

restriction Neq:
  "All a b #x. Neq(a, b) @ #x ==> not (a = b)"

rule KeyGen:
  [ Fr(~prek) ]
  -->
  [ !SecretKey($A, ~prek)
  , !PublicKey($A, 'g'^~prek)
  , Out('g'^~prek) ]

rule SenderStart:
  let dhss = prepk^~x
      k = kdf(dhss, prepk^~prek)
  in
  [ Fr(~id), Fr(~x)
  , !SecretKey($A, ~prek)
  , !PublicKey($B, prepk) ]
  --[ Neq($A, $B)
    , DHSecret(~id, 'g'^~x, prepk, dhss, k)
    , NewDHSecret(~id, 'g'^~x, prepk, dhss, k) ]->
  [ Session(~id, $A, 'S', ~x, $B, prepk, k)
  , Out(<'g'^~x, senc('ack', k)>) ]

rule ReceiverStart:
  let dhss = pc^~prek
      k = kdf(dhss, prepk^~prek)
  in
  [ Fr(~id)
  , !SecretKey($A, ~prek)
  , !PublicKey($B, prepk)
  , In(<pc, enc>) ]
  --[ Neq($A, $B)
    , Neq(pc, DH_neutral)
    , Neq(pc, 'g')
    , DHSecret(~id, 'g'^~prek, pc, dhss, k)
    , NewDHSecret(~id, 'g'^~prek, pc, dhss, k)
    , Eq(decrypts(enc, k), true) ]->
  [ Session(~id, $A, 'R', ~prek, $B, pc, k) ]

rule OuterRatchetToSender:
  let dhss = pc^~x
      k = kdf(dhss, old_k)
  in
  [ Fr(~x), Fr(~m)
  , Session(~id, $A, 'R', drop, $B, pc, old_k) ]
  --[ ToSender(~id, 'g'^~x, dhss, k)
    , DHSecret(~id, 'g'^~x, pc, dhss, k)
    , NewDHSecret(~id, 'g'^~x, pc, dhss, k) ]->
  [ Session(~id, $A, 'S', ~x, $B, pc, k)
  , Out(<'g'^~x, senc('ack', k)>) ]

rule OuterRatchetToReceiver:
  let dhss = pc^~x
      k = kdf(dhss, old_k)
  in
  [ In(<pc, enc>)
  , Session(~id, $A, 'S', ~x, $B, old_pc, old_k) ]
  --[ Neq(pc, DH_neutral)
    , Neq(pc, 'g')
    , ToReceiver(~id, 'g'^~x, dhss, k)
    , DHSecret(~id, 'g'^~x, pc, dhss, k)
    , NewDHSecret(~id, 'g'^~x, pc, dhss, k)
    , Eq(decrypts(enc, k), true) ]->
  [ Session(~id, $A, 'R', ~x, $B, pc, k) ]

lemma Exec:
  exists-trace
  "Ex id1 id2 pc1 pc2 ss k #x #y.
      NewDHSecret(id1, pc1, pc2, ss, k) @ #x
    & ToSender(id1, pc1, ss, k) @ #x
    & NewDHSecret(id2, pc2, pc1, ss, k) @ #y
    & ToReceiver(id2, pc2, ss, k) @ #y"

lemma Secrecy[reuse,use_induction]:
  "All id pc1 pc2 ss k #t. DHSecret(id, pc1, pc2, ss, k) @ #t
  ==> (not Ex #x. KU(ss) @ #x)"

end
