theory Signal_noncommut
begin

builtins: symmetric-encryption
functions: kdf/1, decrypts/2, true/0
equations: decrypts(senc(m, k), k) = true

// Non-commutative DH for speed so that I can debug quicker
functions: dh/2, pk/1, left/2, right/2
equations: left(kl, pk(kr)) = dh(kl, kr), 
  right(kr, pk(kl)) = dh(kl, kr)

restriction Eq:
  "All a b #x. Eq(a, b) @ #x ==> a = b"

restriction Neq:
  "All a b #x. Neq(a, b) @ #x ==> not (a = b)"

rule KeyGen:
  [ Fr(~ltk), Fr(~prek) ]
  -->
  [ !SecretKeys($A, ~ltk, ~prek)
  , !PublicKeys($A, pk(~ltk), pk(~prek))
  , Out(pk(~ltk))
  , Out(pk(~prek)) ]

rule SenderStart:
  let dh1 = left(~ltk, prepk)
      dh2 = left(~x, ltpk)
      dh3 = left(~x, prepk)
      ss = kdf(<dh1, dh2, dh3>)
      rk = kdf(<'rk', ss>)
      ck = kdf(<'ck', rk>)
      mk = kdf(<'mk', ck>)
  in
  [ Fr(~id), Fr(~x), Fr(~m)
  , !SecretKeys($A, ~ltk, prek)
  , !PublicKeys($B, ltpk, prepk) ]
  --[ Neq($A, $B)
    , Send(~m)
    , GenEph(pk(~x)) ]->
  [ Session(~id, $A, 'S', ~x, $B, prepk, rk, ck)
  , Out(<pk(~x), senc(~m, mk)>) ]

rule Send:
  let new_ck = kdf(<'ck', ck>)
      mk = kdf(<'mk', new_ck>)
  in
  [ Fr(~m)
  , Session(~id, $A, 'S', ~x, $B, pc, rk, ck)[no_precomp] ]
  --[ Send(~m) ]->
  [ Session(~id, $A, 'S', ~x, $B, pc, rk, new_ck)
  , Out(senc(~m, mk)) ]

rule ReceiverStart:
  let dh1 = right(~prek, ltpk)
      dh2 = right(~ltk, pc)
      dh3 = right(~prek, pc)
      ss = kdf(<dh1, dh2, dh3>)
      rk = kdf(<'rk', ss>)
      ck = kdf(<'ck', rk>)
      mk = kdf(<'mk', ck>)
  in
  [ Fr(~id)
  , !SecretKeys($A, ~ltk, ~prek)
  , !PublicKeys($B, ltpk, prepk)
  , In(<pc, enc>) ]
  --[ Neq($A, $B)
    , Receive(sdec(enc, mk))
    , Eq(decrypts(enc, mk), true) ]->
  [ Session(~id, $A, 'R', ~prek, $B, pc, rk, ck) ]

rule Receive:
  let new_ck = kdf(<'ck', ck>)
      mk = kdf(<'mk', new_ck>)
  in
  [ In(enc)
  , Session(~id, $A, 'R', ~x, $B, pc, rk, ck)[no_precomp] ]
  --[ Receive(sdec(enc, mk))
    , Eq(decrypts(enc, mk), true) ]->
  [ Session(~id, $A, 'R', ~x, $B, pc, rk, new_ck) ]

rule OuterRatchetToSender:
  let dhss = left(~x, pc)
      rk = kdf(<'rk', old_rk, dhss>)
      ck = kdf(<'ck', rk>)
      mk = kdf(<'mk', ck>)
  in
  [ Fr(~x), Fr(~m)
  , Session(~id, $A, 'R', drop, $B, pc, old_rk, old_ck)[no_precomp] ]
  --[ Send(~m) ]->
  [ Session(~id, $A, 'S', ~x, $B, pc, rk, ck)
  , Out(<pk(~x), senc(~m, mk)>) ]

rule OuterRatchetToReceiver:
  let dhss = right(~x, pc)
      rk = kdf(<'rk', old_rk, dhss>)
      ck = kdf(<'ck', rk>)
      mk = kdf(<'mk', ck>)
  in
  [ In(<pc, enc>)
  , Session(~id, $A, 'S', ~x, $B, old_pc, old_rk, old_ck)[no_precomp] ]
  --[ Receive(sdec(enc, mk))
    , Eq(decrypts(enc, mk), true) ]->
  [ Session(~id, $A, 'R', ~x, $B, pc, rk, ck) ]

lemma Exec:
  exists-trace
  "Ex m #x #y. Receive(m) @ #x & Send(m) @ #y"

lemma Secrecy:
  "All m #t. Send(m) @ #t ==> (not Ex #x. K(m) @ #x)"

end
