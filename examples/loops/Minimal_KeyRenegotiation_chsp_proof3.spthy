theory Minimal_KeyRenegotiation_chsp begin

// Function signature and definition of the equational theory E

functions: fst/1, pair/2, sdec/2, senc/2, snd/1
equations:
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2





/* looping facts with injective instances: Sender/1 */

rule (modulo E) Setup:
   [ Fr( ~k ) ] --> [ Sender( ~k ), Receiver( ~k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Send:
   [ Sender( k0 ), Fr( ~k ) ]
  --[ Secret( ~k ) ]->
   [ Sender( ~k ), Out( senc(~k, k0) ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) Receive:
   [ Receiver( k0 ), In( senc(k, k0) ) ]
  --[ Secret( k ) ]->
   [ Receiver( k ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

lemma Secret_reachable [use_induction]:
  exists-trace "∃ k #i. Secret( k ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ k #i. (Secret( k ) @ #i)"
*/
by sorry

lemma secrecy [use_induction]:
  all-traces
  "∀ k #i #j. ((Secret( k ) @ #i) ∧ (!KU( k ) @ #j)) ⇒ (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ k #i #j. (Secret( k ) @ #i) ∧ (!KU( k ) @ #j)"
*/
simplify
solve( Secret( k ) @ #i )
  case Receive
  set cycle target
  solve( Receiver( k0 ) ▶₀ #i )
    case Receive
    solve( !KU( senc(k, k0) ) @ #vk )
      case Send
      solve( !KU( ~k ) @ #j )
        case Send
        weaken( #i )
        weaken( #j )
        weaken( #vf )
        weaken( #vk )
        weaken( #vr.2 )
        weaken( #vl )
        weaken( #vr.1 )
        weaken( #vf.1 )
        by sorry
      qed
    next
      case c_senc
      weaken( #i )
      weaken( #vf )
      weaken( #vk )
      by sorry
    qed
  next
    case Setup
    solve( !KU( senc(k.1, ~k) ) @ #vk )
      case Send
      solve( !KU( ~k.1 ) @ #j )
        case Send
        by solve( !KU( ~k ) @ #vk.1 )
      qed
    next
      case c_senc
      by solve( !KU( ~k ) @ #vk.1 )
    qed
  qed
next
  case Send
  set cycle target
  solve( !KU( ~k ) @ #j )
    case Send
    solve( Sender( k0 ) ▶₀ #i )
      case Send
      weaken( #j )
      weaken( #vr )
      weaken( #vl )
      weaken( #i )
      weaken( #vf )
      by contradiction /* cyclic proof */
    next
      case Setup
      by solve( !KU( ~k ) @ #vk )
    qed
  qed
qed

lemma secrecy_using_wf_induction:
  all-traces
  "∀ #i #j k.
    (((Secret( k ) @ #i) ∧ (!KU( k ) @ #j)) ∧
     (∀ #i1 #j1 k1.
       (((Secret( k1 ) @ #i1) ∧ (!KU( k1 ) @ #j1)) ∧ (#i1 < #i)) ⇒ (⊥))) ⇒
    (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j k.
  (Secret( k ) @ #i) ∧ (!KU( k ) @ #j)
 ∧
  ∀ #i1 #j1 k1.
   (Secret( k1 ) @ #i1) ∧ (!KU( k1 ) @ #j1) ⇒ ¬(#i1 < #i)"
*/
simplify
solve( Secret( k ) @ #i )
  case Receive
  solve( !KU( senc(k, k0) ) @ #vk )
    case Send
    by contradiction
  next
    case c_senc
    solve( Receiver( k0 ) ▶₀ #i )
      case Receive
      by contradiction
    next
      case Setup
      by solve( !KU( ~k ) @ #vk.1 )
    qed
  qed
next
  case Send
  solve( !KU( ~k ) @ #j )
    case Send
    solve( Sender( k0 ) ▶₀ #i )
      case Send
      by contradiction
    next
      case Setup
      by solve( !KU( ~k ) @ #vk )
    qed
  qed
qed

lemma secrecy_using_wf_induction_also_guarded:
  all-traces
  "∀ #i k.
    (Secret( k ) @ #i) ⇒
    (∀ #j.
      ((!KU( k ) @ #j) ∧
       (∀ #i1 #j1 k1.
         (((Secret( k1 ) @ #i1) ∧ (!KU( k1 ) @ #j1)) ∧ (#i1 < #i)) ⇒ (⊥))) ⇒
      (⊥))"
/*
guarded formula characterizing all counter-examples:
"∃ #i k.
  (Secret( k ) @ #i)
 ∧
  ∃ #j.
   (!KU( k ) @ #j)
  ∧
   ∀ #i1 #j1 k1.
    (Secret( k1 ) @ #i1) ∧ (!KU( k1 ) @ #j1) ⇒ ¬(#i1 < #i)"
*/
by sorry











/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.7.1
Maude version 2.7.1
Git revision: 9aaf3bf6048c93eadff430a0cccbb5b87eddb483, branch: cyclic
Compiled at: 2023-06-30 13:00:09.59599 UTC
*/

end