theory Minimal_HashChain begin

/*
  Protocol:    A minimal HashChain example (inspired by TESLA 2)
  Modeler:     Simon Meier
  Date:        August 2012

  Status:      note yet working
               (requires multiset or repeated exponentiation reasoning)

  This models the key difficulty in the proof of the TESLA 2 protocol with
  re-authentication: the verification that the key checking process is
  sufficient to guarantee that the key is a key of the hash-chain.
*/

functions: f/1

// Chain setup phase
////////////////////

// Hash chain generation
rule Gen_Start:
  [ Fr(seed) ] --> [ Gen(seed, seed), Out(seed) ]

// The NextKey-facts are used by the sender rules to store the link between
// the keys in the chain.
rule Gen_Step:
    [ Gen(seed, chain) ]
  --[ ChainKey(chain)
    ]->
    [ Gen(seed, f(chain) ) ]

// At some point the sender decides to stop the hash-chain precomputation.
rule Gen_Stop:
    [ Gen(seed, kZero) ]
  --[ ChainKey(kZero) ]->
    [ !Final(kZero) ]

// Key checking
///////////////

// Start checking an arbitrary key. Use a loop-id to allow connecting
// different statements about the same loop.
rule Check0:
    [ In(kOrig)
    , Fr(loopId)
    ]
  --[ Start(loopId, kOrig)
    ]->
    [ Loop(loopId, kOrig, kOrig) ]

rule Check:
    [ Loop(loopId, k,    kOrig) ]
  --[ Loop(loopId, k,    kOrig) ]->
    [ Loop(loopId, f(k), kOrig) ]

rule Success:
    [ Loop(loopId, kZero, kOrig), !Final(kZero) ]
  --[ Success(loopId, kOrig)
    ]-> []


// Provable: restricts the search space
lemma Loop_Start:
  "All lid k kOrig #i. Loop(lid, k, kOrig) @ i ==>
    Ex #j. Start(lid, kOrig) @ j & j < i"

// Provable: restricts the search space
lemma Loop_Success_ord:
  "All lid k kOrig1 kOrig2 #i #j.
       Loop(lid, k, kOrig1) @ i
     & Success(lid, kOrig2) @ j
    ==>
     ( i < j)
  "

// Provable: connects an arbitrary loop step with its start.
lemma Loop_charn:
  "All lid k kOrig #i. Loop(lid, k, kOrig) @ i ==>
     Ex #j. Loop(lid, kOrig, kOrig) @ j"

lemma Helper_Loop_and_success[reuse]:
  "All lid kOrig k1 k2 #x #y #z.
      Loop(lid, k1, kOrig) @ #x & Loop(lid, k2, kOrig) @ #y & #y < #x
      & ChainKey(k1) @ #z
    ==> Ex #t. ChainKey(k2) @ #t"
simplify
solve( ChainKey( k ) @ #z )
  case Gen_Step
  solve( Loop( loopId.1, chain, kOrig.2 ) ▶₀ #x )
    case Check
    solve( Gen( seed, f(k.2) ) ▶₀ #z )
      case Gen_Step
      search for cycle
      cut( #y < #vr , ¬(k.1 = k.2) , ¬(k.2 = k.1) )
        case cut
        by contradiction /* cyclic backlink to CS id 3-00 */
      next
        case negate_0
        solve( (#y = #vr)  ∥ (#vr < #y) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          by contradiction /* non-injective facts (#vr,#y,#x) */
        qed
      next
        case negate_1
        by contradiction /* from formulas */
      next
        case negate_2
        by contradiction /* from formulas */
      qed
    qed
  next
    case Check0
    by contradiction /* cyclic */
  qed
next
  case Gen_Stop
  solve( Loop( loopId.1, k.1, kOrig.2 ) ▶₀ #y )
    case Check
    search for cycle
    cut( ∀ #t. (ChainKey( k.2 ) @ #t) ⇒ ⊥ )
      case cut
      by contradiction /* cyclic backlink to CS id 3-04 */
    next
      case negate_0
      solve( Gen( seed, kZero ) ▶₀ #z )
        case Gen_Start
        by contradiction /* cyclic */
      next
        case Gen_Step
        weaken node( #z )
        solve( Loop( loopId.1, f(chain), kOrig.2 ) ▶₀ #x )
          case Check
          solve( Gen( seed, chain ) ▶₀ #vr.1 )
            case Gen_Start
            simplify
            by contradiction /* cyclic */
          next
            case Gen_Step
            search for cycle
            cut( #y < #vr.2 , ¬(k.2 = f(chain.1)) , ¬(f(chain.1) = k.2) ,
                 ¬(f(chain.1) = f(k.2)) , ¬(f(k.2) = f(chain.1)) )
              case cut
              by contradiction /* cyclic backlink to CS id 8-6c */
            next
              case negate_0
              solve( (#y = #vr.2)  ∥ (#vr.2 < #y) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* non-injective facts (#vr.2,#y,#x) */
              qed
            next
              case negate_1
              by contradiction /* cyclic */
            next
              case negate_2
              by contradiction /* cyclic */
            next
              case negate_3
              by contradiction /* from formulas */
            next
              case negate_4
              by contradiction /* from formulas */
            qed
          qed
        next
          case Check0
          by contradiction /* cyclic */
        qed
      qed
    qed
  next
    case Check0
    solve( Loop( ~n, kZero, kOrig.2 ) ▶₀ #x )
      case Check
      solve( Gen( seed, f(k.2) ) ▶₀ #z )
        case Gen_Step
        search for cycle
        minimize for cyclic proofs
          case negate_0
          by contradiction /* from formulas */
        next
          case weaken
          solve( Loop( ~n, k.2, kOrig.2 ) ▶₀ #vr.1 )
            case Check
            solve( Gen( seed, f(k.3) ) ▶₀ #vr.2 )
              case Gen_Step
              search for cycle
              cut( ¬(kOrig.2 = f(k.3)) , ¬(f(k.3) = kOrig.2) )
                case cut
                by contradiction /* cyclic backlink to CS id 8-14 */
              next
                case negate_0
                by contradiction /* from formulas */
              next
                case negate_1
                by contradiction /* from formulas */
              qed
            qed
          next
            case Check0
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case Check0
      by contradiction /* cyclic */
    qed
  qed
qed

lemma Loop_and_success:
  "All lid k kOrig1 kOrig2 #i #j.
       Loop(lid, k, kOrig1) @ i
     & Success(lid, kOrig2) @ j
    ==>
     (Ex #j. ChainKey(k) @ j)
  "
simplify
solve( Loop( loopId.1, kZero, kOrig.1 ) ▶₀ #j )
  case Check
  solve( !Final( f(k.2) ) ▶₁ #j )
    case Gen_Stop
    solve( Loop( loopId.1, k.1, kOrig.1 ) ▶₀ #i )
      case Check
      search for cycle
      cut( ∀ #j. (ChainKey( k.3 ) @ #j) ⇒ ⊥ )
        case cut
        by contradiction /* cyclic backlink to CS id 4-04 */
      next
        case negate_0
        solve( (¬(#i < #vr))  ∥ (∃ #t. (ChainKey( f(k.3) ) @ #t)) )
          case case_1
          solve( (#i = #vr)  ∥ (#vr < #i) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            weaken formula( ∀ #j. (ChainKey( f(k.3) ) @ #j) ⇒ ⊥ )
            solve( Loop( loopId.1, k.3, kOrig.1 ) ▶₀ #vr.3 )
              case Check
              search for cycle
              cut( #vr < #vr.3 , ¬(k.2 = f(k.4)) , ¬(f(k.4) = k.2) )
                case cut
                by contradiction /* cyclic backlink to CS id 10-0154 */
              next
                case negate_0
                solve( (#vr = #vr.3)  ∥ (#vr.3 < #vr) )
                  case case_2
                  by contradiction /* non-injective facts (#vr.3,#vr,#i) */
                qed
              qed
            next
              case Check0
              by contradiction /* cyclic */
            qed
          qed
        next
          case case_2
          by contradiction /* from formulas */
        qed
      qed
    next
      case Check0
      solve( (¬(#i < #vr))  ∥ (∃ #t. (ChainKey( kOrig.1 ) @ #t)) )
        case case_1
        solve( Loop( ~n, k.2, kOrig.1 ) ▶₀ #vr )
          case Check
          solve( (#i = #vr)  ∥ (#vr < #i) )
            case case_2
            by contradiction /* cyclic */
          qed
        next
          case Check0
          by contradiction /* from formulas */
        qed
      next
        case case_2
        by contradiction /* from formulas */
      qed
    qed
  qed
next
  case Check0
  weaken formula( ∀ #j. (ChainKey( k.1 ) @ #j) ⇒ ⊥ )
  solve( Loop( ~n, k.1, kOrig.1 ) ▶₀ #i )
    case Check
    search for cycle
    by contradiction /* cyclic backlink to CS id 4-00 */
  qed
qed

lemma Helper_Success_charn[hide_lemma=Helper_Loop_and_success]:
  "All lid k kOrig #x #y.
      ChainKey(k) @ #x & Loop(lid, k, kOrig) @ #y
    ==> Ex #z. ChainKey(kOrig) @ #z"

lemma Success_charn[hide_lemma=Helper_Loop_and_success]:
  "All lid k #i. Success(lid, k) @ i ==>
    Ex #j. ChainKey(k) @ j"

// lemma TP:
//   "All #x #y #z. #x < #y & #y < #z ==> #x < #z"

/* A try on building the required 'smaller' relation in an axiomatic fashion.
   This interacts too strongly with

   Does not really work! We need a better way to express this stuff.

rule Succ_to_Smaller:
    [ !Succ(x, y) ] --[ IsSmaller(x, y) ]-> [!Smaller(x, y)]

rule Smaller_Extend:
    [ !Succ(x, y), !Smaller(y, z) ]
  --[ IsSmaller(x, z) ]->
    [ !Smaller(x, z) ]

restriction force_succ_smaller:
    "All #t1 2 a b c. IsSucc(a,b)@t1
       ==> Ex #t2 . IsSmaller(a,b)@t2 "

restriction transitivity:
    "All #t1 #t2 a b c. IsSmaller(a,b)@t1 & IsSmaller(b,c)@t2
       ==> Ex #t3 . IsSmaller(a,c)@t3 "
*/
end
