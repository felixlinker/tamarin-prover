theory Minimal_Loop_Example begin

// Function signature and definition of the equational theory E

functions: fst/1, pair/2, snd/1
equations: fst(<x.1, x.2>) = x.1, snd(<x.1, x.2>) = x.2





/* looping facts with injective instances: A/1 */

rule (modulo E) Start:
   [ Fr( x ) ] --[ Start( x ) ]-> [ A( x ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Loop:
   [ A( x ) ] --[ Loop( x ) ]-> [ A( x ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) Stop:
   [ A( x ) ] --[ Stop( x ) ]-> [ ]

  /* has exactly the trivial AC variant */

lemma Start_before_Loop:
  all-traces
  "∀ x #j. (Loop( x ) @ #j) ⇒ (∃ #i. (Start( x ) @ #i) ∧ (#i < #j))"
/*
guarded formula characterizing all counter-examples:
"∃ x #j. (Loop( x ) @ #j) ∧ ∀ #i. (Start( x ) @ #i) ⇒ ¬(#i < #j)"
*/
simplify
solve( solve( A( x.1 ) ▶₀ #j ) )
  case Loop
  solve( cut( ∀ #i. (Start( x.1 ) @ #i) ⇒ ¬(#i < #vr) ) )
    case cut
    by contradiction /* cyclic proof with CS id 1#0 */
  next
    case negate_0
    by contradiction /* from formulas */
  qed
next
  case Start
  by contradiction /* from formulas */
qed

lemma Start_before_Stop:
  all-traces
  "∀ x #j. (Stop( x ) @ #j) ⇒ (∃ #i. (Start( x ) @ #i) ∧ (#i < #j))"
/*
guarded formula characterizing all counter-examples:
"∃ x #j. (Stop( x ) @ #j) ∧ ∀ #i. (Start( x ) @ #i) ⇒ ¬(#i < #j)"
*/
simplify
solve( solve( A( x.1 ) ▶₀ #j ) )
  case Loop
  solve( weaken node( #j ) )
  solve( solve( A( x.1 ) ▶₀ #vr ) )
    case Loop
    by contradiction /* cyclic proof with CS id 3#2 */
  next
    case Start
    by contradiction /* from formulas */
  qed
next
  case Start
  by contradiction /* from formulas */
qed

lemma Loop_before_Stop:
  all-traces
  "∀ x #i #j. ((Stop( x ) @ #j) ∧ (Loop( x ) @ #i)) ⇒ (#i < #j)"
/*
guarded formula characterizing all counter-examples:
"∃ x #i #j. (Stop( x ) @ #j) ∧ (Loop( x ) @ #i) ∧ ¬(#i < #j)"
*/
simplify
solve( solve( A( x.2 ) ▶₀ #i ) )
  case Loop
  solve( cut( #j < #vr , ((#vr = #j) ∨ (#j < #vr)) ) )
    case cut
    by contradiction /* cyclic proof with CS id 1#0 */
  next
    case negate_0
    by contradiction /* from formulas */
  next
    case negate_1
    by contradiction /* from formulas */
  qed
next
  case Start
  by contradiction /* cyclic */
qed

lemma Stop_unique:
  all-traces
  "∀ x #i #j. ((Stop( x ) @ #j) ∧ (Stop( x ) @ #i)) ⇒ (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ x #i #j. (Stop( x ) @ #j) ∧ (Stop( x ) @ #i) ∧ ¬(#i = #j)"
*/
simplify
solve( solve( (#i < #j)  ∥ (#j < #i) ) )
  case case_1
  solve( solve( A( x.2 ) ▶₀ #i ) )
    case Loop
    solve( solve( A( x.2 ) ▶₀ #j ) )
      case Loop
      solve( weaken node( #j ) )
      solve( solve( A( x.2 ) ▶₀ #vr.1 ) )
        case Loop
        by contradiction /* cyclic proof with CS id 5#6 */
      next
        case Start
        by contradiction /* cyclic */
      qed
    next
      case Start
      by contradiction /* cyclic */
    qed
  next
    case Start
    solve( solve( A( ~n ) ▶₀ #j ) )
      case Loop
      solve( weaken node( #j ) )
      solve( solve( A( ~n ) ▶₀ #vr.1 ) )
        case Loop
        by contradiction /* cyclic proof with CS id 5#2 */
      qed
    next
      case Start
      by contradiction /* cyclic */
    qed
  qed
next
  case case_2
  solve( solve( A( x.2 ) ▶₀ #i ) )
    case Loop
    solve( solve( A( x.2 ) ▶₀ #j ) )
      case Loop
      solve( weaken node( #i ) )
      solve( solve( A( x.2 ) ▶₀ #vr ) )
        case Loop
        by contradiction /* cyclic proof with CS id 5#e */
      next
        case Start
        by contradiction /* cyclic */
      qed
    next
      case Start
      solve( weaken node( #i ) )
      solve( solve( A( ~n ) ▶₀ #vr ) )
        case Loop
        by contradiction /* cyclic proof with CS id 5#c */
      qed
    qed
  next
    case Start
    by contradiction /* cyclic */
  qed
qed

lemma Satisfied_by_empty_trace_only:
  exists-trace "∀ x #j. (Loop( x ) @ #j) ⇒ (⊥)"
/*
guarded formula characterizing all satisfying traces:
"∀ x #j. (Loop( x ) @ #j) ⇒ ⊥"
*/
by sorry

lemma False:
  all-traces
  "∀ x #i. (Stop( x ) @ #i) ⇒ (∃ #j. (Loop( x ) @ #j) ∧ (#i < #j))"
/*
guarded formula characterizing all counter-examples:
"∃ x #i. (Stop( x ) @ #i) ∧ ∀ #j. (Loop( x ) @ #j) ⇒ ¬(#i < #j)"
*/
by sorry







/*
WARNING: the following wellformedness checks failed!

Message Derivation Checks
=========================

  The variables of the follwing rule(s) are not derivable from their premises, you may be performing unintended pattern matching.

Rule Start: 
Failed to derive Variable(s): x

Rule Loop: 
Failed to derive Variable(s): x

Rule Stop: 
Failed to derive Variable(s): x
*/

/*
Generated from:
Tamarin version 1.9.0
Maude version 3.3.1
Git revision: 4e738803099a4a29e0e4754065700534d762e219 (with uncommited changes), branch: cyclic
Compiled at: 2024-03-04 16:21:58.525728 UTC
*/

end